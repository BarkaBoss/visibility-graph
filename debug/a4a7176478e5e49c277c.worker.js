!function(n){var g={};function I(e){if(g[e])return g[e].exports;var i=g[e]={i:e,l:!1,exports:{}};return n[e].call(i.exports,i,i.exports,I),i.l=!0,i.exports}I.m=n,I.c=g,I.d=function(n,g,e){I.o(n,g)||Object.defineProperty(n,g,{enumerable:!0,get:e})},I.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},I.t=function(n,g){if(1&g&&(n=I(n)),8&g)return n;if(4&g&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(I.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&g&&"string"!=typeof n)for(var i in n)I.d(e,i,function(g){return n[g]}.bind(null,i));return e},I.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return I.d(g,"a",g),g},I.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},I.p="https://rowanwins.github.io/visibility-graph/debug/",I(I.s=3)}([function(module,exports,__webpack_require__){eval("/**\n * @fileOverview Contains definition of the core graph object.\n */\n\n// TODO: need to change storage layer:\n// 1. Be able to get all nodes O(1)\n// 2. Be able to get number of links O(1)\n\n/**\n * @example\n *  var graph = require('ngraph.graph')();\n *  graph.addNode(1);     // graph has one node.\n *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n *\n */\nmodule.exports = createGraph;\n\nvar eventify = __webpack_require__(1);\n\n/**\n * Creates a new graph\n */\nfunction createGraph(options) {\n  // Graph structure is maintained as dictionary of nodes\n  // and array of links. Each node has 'links' property which\n  // hold all links related to that node. And general links\n  // array is used to speed up all links enumeration. This is inefficient\n  // in terms of memory, but simplifies coding.\n  options = options || {};\n  if ('uniqueLinkId' in options) {\n    console.warn(\n      'ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\\n' +\n      'Use `multigraph` option instead\\n',\n      '\\n',\n      'Note: there is also change in default behavior: From now on each graph\\n'+\n      'is considered to be not a multigraph by default (each edge is unique).'\n    );\n\n    options.multigraph = options.uniqueLinkId;\n  }\n\n  // Dear reader, the non-multigraphs do not guarantee that there is only\n  // one link for a given pair of node. When this option is set to false\n  // we can save some memory and CPU (18% faster for non-multigraph);\n  if (options.multigraph === undefined) options.multigraph = false;\n\n  var nodes = typeof Object.create === 'function' ? Object.create(null) : {},\n    links = [],\n    // Hash of multi-edges. Used to track ids of edges between same nodes\n    multiEdges = {},\n    nodesCount = 0,\n    suspendEvents = 0,\n\n    forEachNode = createNodeIterator(),\n    createLink = options.multigraph ? createUniqueLink : createSingleLink,\n\n    // Our graph API provides means to listen to graph changes. Users can subscribe\n    // to be notified about changes in the graph by using `on` method. However\n    // in some cases they don't use it. To avoid unnecessary memory consumption\n    // we will not record graph changes until we have at least one subscriber.\n    // Code below supports this optimization.\n    //\n    // Accumulates all changes made during graph updates.\n    // Each change element contains:\n    //  changeType - one of the strings: 'add', 'remove' or 'update';\n    //  node - if change is related to node this property is set to changed graph's node;\n    //  link - if change is related to link this property is set to changed graph's link;\n    changes = [],\n    recordLinkChange = noop,\n    recordNodeChange = noop,\n    enterModification = noop,\n    exitModification = noop;\n\n  // this is our public API:\n  var graphPart = {\n    /**\n     * Adds node to the graph. If node with given id already exists in the graph\n     * its data is extended with whatever comes in 'data' argument.\n     *\n     * @param nodeId the node's identifier. A string or number is preferred.\n     * @param [data] additional data for the node being added. If node already\n     *   exists its data object is augmented with the new one.\n     *\n     * @return {node} The newly added node or node with given id if it already exists.\n     */\n    addNode: addNode,\n\n    /**\n     * Adds a link to the graph. The function always create a new\n     * link between two nodes. If one of the nodes does not exists\n     * a new node is created.\n     *\n     * @param fromId link start node id;\n     * @param toId link end node id;\n     * @param [data] additional data to be set on the new link;\n     *\n     * @return {link} The newly created link\n     */\n    addLink: addLink,\n\n    /**\n     * Removes link from the graph. If link does not exist does nothing.\n     *\n     * @param link - object returned by addLink() or getLinks() methods.\n     *\n     * @returns true if link was removed; false otherwise.\n     */\n    removeLink: removeLink,\n\n    /**\n     * Removes node with given id from the graph. If node does not exist in the graph\n     * does nothing.\n     *\n     * @param nodeId node's identifier passed to addNode() function.\n     *\n     * @returns true if node was removed; false otherwise.\n     */\n    removeNode: removeNode,\n\n    /**\n     * Gets node with given identifier. If node does not exist undefined value is returned.\n     *\n     * @param nodeId requested node identifier;\n     *\n     * @return {node} in with requested identifier or undefined if no such node exists.\n     */\n    getNode: getNode,\n\n    /**\n     * Gets number of nodes in this graph.\n     *\n     * @return number of nodes in the graph.\n     */\n    getNodesCount: function () {\n      return nodesCount;\n    },\n\n    /**\n     * Gets total number of links in the graph.\n     */\n    getLinksCount: function () {\n      return links.length;\n    },\n\n    /**\n     * Gets all links (inbound and outbound) from the node with given id.\n     * If node with given id is not found null is returned.\n     *\n     * @param nodeId requested node identifier.\n     *\n     * @return Array of links from and to requested node if such node exists;\n     *   otherwise null is returned.\n     */\n    getLinks: getLinks,\n\n    /**\n     * Invokes callback on each node of the graph.\n     *\n     * @param {Function(node)} callback Function to be invoked. The function\n     *   is passed one argument: visited node.\n     */\n    forEachNode: forEachNode,\n\n    /**\n     * Invokes callback on every linked (adjacent) node to the given one.\n     *\n     * @param nodeId Identifier of the requested node.\n     * @param {Function(node, link)} callback Function to be called on all linked nodes.\n     *   The function is passed two parameters: adjacent node and link object itself.\n     * @param oriented if true graph treated as oriented.\n     */\n    forEachLinkedNode: forEachLinkedNode,\n\n    /**\n     * Enumerates all links in the graph\n     *\n     * @param {Function(link)} callback Function to be called on all links in the graph.\n     *   The function is passed one parameter: graph's link object.\n     *\n     * Link object contains at least the following fields:\n     *  fromId - node id where link starts;\n     *  toId - node id where link ends,\n     *  data - additional data passed to graph.addLink() method.\n     */\n    forEachLink: forEachLink,\n\n    /**\n     * Suspend all notifications about graph changes until\n     * endUpdate is called.\n     */\n    beginUpdate: enterModification,\n\n    /**\n     * Resumes all notifications about graph changes and fires\n     * graph 'changed' event in case there are any pending changes.\n     */\n    endUpdate: exitModification,\n\n    /**\n     * Removes all nodes and links from the graph.\n     */\n    clear: clear,\n\n    /**\n     * Detects whether there is a link between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     * NOTE: this function is synonim for getLink()\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    hasLink: getLink,\n\n    /**\n     * Detects whether there is a node with given id\n     * \n     * Operation complexity is O(1)\n     * NOTE: this function is synonim for getNode()\n     *\n     * @returns node if there is one; Falsy value otherwise.\n     */\n    hasNode: getNode,\n\n    /**\n     * Gets an edge between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     *\n     * @param {string} fromId link start identifier\n     * @param {string} toId link end identifier\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    getLink: getLink\n  };\n\n  // this will add `on()` and `fire()` methods.\n  eventify(graphPart);\n\n  monitorSubscribers();\n\n  return graphPart;\n\n  function monitorSubscribers() {\n    var realOn = graphPart.on;\n\n    // replace real `on` with our temporary on, which will trigger change\n    // modification monitoring:\n    graphPart.on = on;\n\n    function on() {\n      // now it's time to start tracking stuff:\n      graphPart.beginUpdate = enterModification = enterModificationReal;\n      graphPart.endUpdate = exitModification = exitModificationReal;\n      recordLinkChange = recordLinkChangeReal;\n      recordNodeChange = recordNodeChangeReal;\n\n      // this will replace current `on` method with real pub/sub from `eventify`.\n      graphPart.on = realOn;\n      // delegate to real `on` handler:\n      return realOn.apply(graphPart, arguments);\n    }\n  }\n\n  function recordLinkChangeReal(link, changeType) {\n    changes.push({\n      link: link,\n      changeType: changeType\n    });\n  }\n\n  function recordNodeChangeReal(node, changeType) {\n    changes.push({\n      node: node,\n      changeType: changeType\n    });\n  }\n\n  function addNode(nodeId, data) {\n    if (nodeId === undefined) {\n      throw new Error('Invalid node identifier');\n    }\n\n    enterModification();\n\n    var node = getNode(nodeId);\n    if (!node) {\n      node = new Node(nodeId, data);\n      nodesCount++;\n      recordNodeChange(node, 'add');\n    } else {\n      node.data = data;\n      recordNodeChange(node, 'update');\n    }\n\n    nodes[nodeId] = node;\n\n    exitModification();\n    return node;\n  }\n\n  function getNode(nodeId) {\n    return nodes[nodeId];\n  }\n\n  function removeNode(nodeId) {\n    var node = getNode(nodeId);\n    if (!node) {\n      return false;\n    }\n\n    enterModification();\n\n    var prevLinks = node.links;\n    if (prevLinks) {\n      node.links = null;\n      for(var i = 0; i < prevLinks.length; ++i) {\n        removeLink(prevLinks[i]);\n      }\n    }\n\n    delete nodes[nodeId];\n    nodesCount--;\n\n    recordNodeChange(node, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n\n  function addLink(fromId, toId, data) {\n    enterModification();\n\n    var fromNode = getNode(fromId) || addNode(fromId);\n    var toNode = getNode(toId) || addNode(toId);\n\n    var link = createLink(fromId, toId, data);\n\n    links.push(link);\n\n    // TODO: this is not cool. On large graphs potentially would consume more memory.\n    addLinkToNode(fromNode, link);\n    if (fromId !== toId) {\n      // make sure we are not duplicating links for self-loops\n      addLinkToNode(toNode, link);\n    }\n\n    recordLinkChange(link, 'add');\n\n    exitModification();\n\n    return link;\n  }\n\n  function createSingleLink(fromId, toId, data) {\n    var linkId = makeLinkId(fromId, toId);\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function createUniqueLink(fromId, toId, data) {\n    // TODO: Get rid of this method.\n    var linkId = makeLinkId(fromId, toId);\n    var isMultiEdge = multiEdges.hasOwnProperty(linkId);\n    if (isMultiEdge || getLink(fromId, toId)) {\n      if (!isMultiEdge) {\n        multiEdges[linkId] = 0;\n      }\n      var suffix = '@' + (++multiEdges[linkId]);\n      linkId = makeLinkId(fromId + suffix, toId + suffix);\n    }\n\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function getLinks(nodeId) {\n    var node = getNode(nodeId);\n    return node ? node.links : null;\n  }\n\n  function removeLink(link) {\n    if (!link) {\n      return false;\n    }\n    var idx = indexOfElementInArray(link, links);\n    if (idx < 0) {\n      return false;\n    }\n\n    enterModification();\n\n    links.splice(idx, 1);\n\n    var fromNode = getNode(link.fromId);\n    var toNode = getNode(link.toId);\n\n    if (fromNode) {\n      idx = indexOfElementInArray(link, fromNode.links);\n      if (idx >= 0) {\n        fromNode.links.splice(idx, 1);\n      }\n    }\n\n    if (toNode) {\n      idx = indexOfElementInArray(link, toNode.links);\n      if (idx >= 0) {\n        toNode.links.splice(idx, 1);\n      }\n    }\n\n    recordLinkChange(link, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n  function getLink(fromNodeId, toNodeId) {\n    // TODO: Use sorted links to speed this up\n    var node = getNode(fromNodeId),\n      i;\n    if (!node || !node.links) {\n      return null;\n    }\n\n    for (i = 0; i < node.links.length; ++i) {\n      var link = node.links[i];\n      if (link.fromId === fromNodeId && link.toId === toNodeId) {\n        return link;\n      }\n    }\n\n    return null; // no link.\n  }\n\n  function clear() {\n    enterModification();\n    forEachNode(function(node) {\n      removeNode(node.id);\n    });\n    exitModification();\n  }\n\n  function forEachLink(callback) {\n    var i, length;\n    if (typeof callback === 'function') {\n      for (i = 0, length = links.length; i < length; ++i) {\n        callback(links[i]);\n      }\n    }\n  }\n\n  function forEachLinkedNode(nodeId, callback, oriented) {\n    var node = getNode(nodeId);\n\n    if (node && node.links && typeof callback === 'function') {\n      if (oriented) {\n        return forEachOrientedLink(node.links, nodeId, callback);\n      } else {\n        return forEachNonOrientedLink(node.links, nodeId, callback);\n      }\n    }\n  }\n\n  function forEachNonOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n\n      quitFast = callback(nodes[linkedNodeId], link);\n      if (quitFast) {\n        return true; // Client does not need more iterations. Break now.\n      }\n    }\n  }\n\n  function forEachOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      if (link.fromId === nodeId) {\n        quitFast = callback(nodes[link.toId], link);\n        if (quitFast) {\n          return true; // Client does not need more iterations. Break now.\n        }\n      }\n    }\n  }\n\n  // we will not fire anything until users of this library explicitly call `on()`\n  // method.\n  function noop() {}\n\n  // Enter, Exit modification allows bulk graph updates without firing events.\n  function enterModificationReal() {\n    suspendEvents += 1;\n  }\n\n  function exitModificationReal() {\n    suspendEvents -= 1;\n    if (suspendEvents === 0 && changes.length > 0) {\n      graphPart.fire('changed', changes);\n      changes.length = 0;\n    }\n  }\n\n  function createNodeIterator() {\n    // Object.keys iterator is 1.3x faster than `for in` loop.\n    // See `https://github.com/anvaka/ngraph.graph/tree/bench-for-in-vs-obj-keys`\n    // branch for perf test\n    return Object.keys ? objectKeysIterator : forInIterator;\n  }\n\n  function objectKeysIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n\n    var keys = Object.keys(nodes);\n    for (var i = 0; i < keys.length; ++i) {\n      if (callback(nodes[keys[i]])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n\n  function forInIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n    var node;\n\n    for (node in nodes) {\n      if (callback(nodes[node])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n}\n\n// need this for old browsers. Should this be a separate module?\nfunction indexOfElementInArray(element, array) {\n  if (!array) return -1;\n\n  if (array.indexOf) {\n    return array.indexOf(element);\n  }\n\n  var len = array.length,\n    i;\n\n  for (i = 0; i < len; i += 1) {\n    if (array[i] === element) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Internal structure to represent node;\n */\nfunction Node(id, data) {\n  this.id = id;\n  this.links = null;\n  this.data = data;\n}\n\nfunction addLinkToNode(node, link) {\n  if (node.links) {\n    node.links.push(link);\n  } else {\n    node.links = [link];\n  }\n}\n\n/**\n * Internal structure to represent links;\n */\nfunction Link(fromId, toId, data, id) {\n  this.fromId = fromId;\n  this.toId = toId;\n  this.data = data;\n  this.id = id;\n}\n\nfunction hashCode(str) {\n  var hash = 0, i, chr, len;\n  if (str.length == 0) return hash;\n  for (i = 0, len = str.length; i < len; i++) {\n    chr   = str.charCodeAt(i);\n    hash  = ((hash << 5) - hash) + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\nfunction makeLinkId(fromId, toId) {\n  return fromId.toString() + '👉 ' + toId.toString();\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmdyYXBoLmdyYXBoL2luZGV4LmpzPzE0OGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMsQ0FBZTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgQ29udGFpbnMgZGVmaW5pdGlvbiBvZiB0aGUgY29yZSBncmFwaCBvYmplY3QuXG4gKi9cblxuLy8gVE9ETzogbmVlZCB0byBjaGFuZ2Ugc3RvcmFnZSBsYXllcjpcbi8vIDEuIEJlIGFibGUgdG8gZ2V0IGFsbCBub2RlcyBPKDEpXG4vLyAyLiBCZSBhYmxlIHRvIGdldCBudW1iZXIgb2YgbGlua3MgTygxKVxuXG4vKipcbiAqIEBleGFtcGxlXG4gKiAgdmFyIGdyYXBoID0gcmVxdWlyZSgnbmdyYXBoLmdyYXBoJykoKTtcbiAqICBncmFwaC5hZGROb2RlKDEpOyAgICAgLy8gZ3JhcGggaGFzIG9uZSBub2RlLlxuICogIGdyYXBoLmFkZExpbmsoMiwgMyk7ICAvLyBub3cgZ3JhcGggY29udGFpbnMgdGhyZWUgbm9kZXMgYW5kIG9uZSBsaW5rLlxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVHcmFwaDtcblxudmFyIGV2ZW50aWZ5ID0gcmVxdWlyZSgnbmdyYXBoLmV2ZW50cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZ3JhcGhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlR3JhcGgob3B0aW9ucykge1xuICAvLyBHcmFwaCBzdHJ1Y3R1cmUgaXMgbWFpbnRhaW5lZCBhcyBkaWN0aW9uYXJ5IG9mIG5vZGVzXG4gIC8vIGFuZCBhcnJheSBvZiBsaW5rcy4gRWFjaCBub2RlIGhhcyAnbGlua3MnIHByb3BlcnR5IHdoaWNoXG4gIC8vIGhvbGQgYWxsIGxpbmtzIHJlbGF0ZWQgdG8gdGhhdCBub2RlLiBBbmQgZ2VuZXJhbCBsaW5rc1xuICAvLyBhcnJheSBpcyB1c2VkIHRvIHNwZWVkIHVwIGFsbCBsaW5rcyBlbnVtZXJhdGlvbi4gVGhpcyBpcyBpbmVmZmljaWVudFxuICAvLyBpbiB0ZXJtcyBvZiBtZW1vcnksIGJ1dCBzaW1wbGlmaWVzIGNvZGluZy5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgndW5pcXVlTGlua0lkJyBpbiBvcHRpb25zKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ25ncmFwaC5ncmFwaDogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDAuMTQgYHVuaXF1ZUxpbmtJZGAgaXMgZGVwcmVjYXRlZC5cXG4nICtcbiAgICAgICdVc2UgYG11bHRpZ3JhcGhgIG9wdGlvbiBpbnN0ZWFkXFxuJyxcbiAgICAgICdcXG4nLFxuICAgICAgJ05vdGU6IHRoZXJlIGlzIGFsc28gY2hhbmdlIGluIGRlZmF1bHQgYmVoYXZpb3I6IEZyb20gbm93IG9uIGVhY2ggZ3JhcGhcXG4nK1xuICAgICAgJ2lzIGNvbnNpZGVyZWQgdG8gYmUgbm90IGEgbXVsdGlncmFwaCBieSBkZWZhdWx0IChlYWNoIGVkZ2UgaXMgdW5pcXVlKS4nXG4gICAgKTtcblxuICAgIG9wdGlvbnMubXVsdGlncmFwaCA9IG9wdGlvbnMudW5pcXVlTGlua0lkO1xuICB9XG5cbiAgLy8gRGVhciByZWFkZXIsIHRoZSBub24tbXVsdGlncmFwaHMgZG8gbm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG9ubHlcbiAgLy8gb25lIGxpbmsgZm9yIGEgZ2l2ZW4gcGFpciBvZiBub2RlLiBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCB0byBmYWxzZVxuICAvLyB3ZSBjYW4gc2F2ZSBzb21lIG1lbW9yeSBhbmQgQ1BVICgxOCUgZmFzdGVyIGZvciBub24tbXVsdGlncmFwaCk7XG4gIGlmIChvcHRpb25zLm11bHRpZ3JhcGggPT09IHVuZGVmaW5lZCkgb3B0aW9ucy5tdWx0aWdyYXBoID0gZmFsc2U7XG5cbiAgdmFyIG5vZGVzID0gdHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge30sXG4gICAgbGlua3MgPSBbXSxcbiAgICAvLyBIYXNoIG9mIG11bHRpLWVkZ2VzLiBVc2VkIHRvIHRyYWNrIGlkcyBvZiBlZGdlcyBiZXR3ZWVuIHNhbWUgbm9kZXNcbiAgICBtdWx0aUVkZ2VzID0ge30sXG4gICAgbm9kZXNDb3VudCA9IDAsXG4gICAgc3VzcGVuZEV2ZW50cyA9IDAsXG5cbiAgICBmb3JFYWNoTm9kZSA9IGNyZWF0ZU5vZGVJdGVyYXRvcigpLFxuICAgIGNyZWF0ZUxpbmsgPSBvcHRpb25zLm11bHRpZ3JhcGggPyBjcmVhdGVVbmlxdWVMaW5rIDogY3JlYXRlU2luZ2xlTGluayxcblxuICAgIC8vIE91ciBncmFwaCBBUEkgcHJvdmlkZXMgbWVhbnMgdG8gbGlzdGVuIHRvIGdyYXBoIGNoYW5nZXMuIFVzZXJzIGNhbiBzdWJzY3JpYmVcbiAgICAvLyB0byBiZSBub3RpZmllZCBhYm91dCBjaGFuZ2VzIGluIHRoZSBncmFwaCBieSB1c2luZyBgb25gIG1ldGhvZC4gSG93ZXZlclxuICAgIC8vIGluIHNvbWUgY2FzZXMgdGhleSBkb24ndCB1c2UgaXQuIFRvIGF2b2lkIHVubmVjZXNzYXJ5IG1lbW9yeSBjb25zdW1wdGlvblxuICAgIC8vIHdlIHdpbGwgbm90IHJlY29yZCBncmFwaCBjaGFuZ2VzIHVudGlsIHdlIGhhdmUgYXQgbGVhc3Qgb25lIHN1YnNjcmliZXIuXG4gICAgLy8gQ29kZSBiZWxvdyBzdXBwb3J0cyB0aGlzIG9wdGltaXphdGlvbi5cbiAgICAvL1xuICAgIC8vIEFjY3VtdWxhdGVzIGFsbCBjaGFuZ2VzIG1hZGUgZHVyaW5nIGdyYXBoIHVwZGF0ZXMuXG4gICAgLy8gRWFjaCBjaGFuZ2UgZWxlbWVudCBjb250YWluczpcbiAgICAvLyAgY2hhbmdlVHlwZSAtIG9uZSBvZiB0aGUgc3RyaW5nczogJ2FkZCcsICdyZW1vdmUnIG9yICd1cGRhdGUnO1xuICAgIC8vICBub2RlIC0gaWYgY2hhbmdlIGlzIHJlbGF0ZWQgdG8gbm9kZSB0aGlzIHByb3BlcnR5IGlzIHNldCB0byBjaGFuZ2VkIGdyYXBoJ3Mgbm9kZTtcbiAgICAvLyAgbGluayAtIGlmIGNoYW5nZSBpcyByZWxhdGVkIHRvIGxpbmsgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gY2hhbmdlZCBncmFwaCdzIGxpbms7XG4gICAgY2hhbmdlcyA9IFtdLFxuICAgIHJlY29yZExpbmtDaGFuZ2UgPSBub29wLFxuICAgIHJlY29yZE5vZGVDaGFuZ2UgPSBub29wLFxuICAgIGVudGVyTW9kaWZpY2F0aW9uID0gbm9vcCxcbiAgICBleGl0TW9kaWZpY2F0aW9uID0gbm9vcDtcblxuICAvLyB0aGlzIGlzIG91ciBwdWJsaWMgQVBJOlxuICB2YXIgZ3JhcGhQYXJ0ID0ge1xuICAgIC8qKlxuICAgICAqIEFkZHMgbm9kZSB0byB0aGUgZ3JhcGguIElmIG5vZGUgd2l0aCBnaXZlbiBpZCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZ3JhcGhcbiAgICAgKiBpdHMgZGF0YSBpcyBleHRlbmRlZCB3aXRoIHdoYXRldmVyIGNvbWVzIGluICdkYXRhJyBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgdGhlIG5vZGUncyBpZGVudGlmaWVyLiBBIHN0cmluZyBvciBudW1iZXIgaXMgcHJlZmVycmVkLlxuICAgICAqIEBwYXJhbSBbZGF0YV0gYWRkaXRpb25hbCBkYXRhIGZvciB0aGUgbm9kZSBiZWluZyBhZGRlZC4gSWYgbm9kZSBhbHJlYWR5XG4gICAgICogICBleGlzdHMgaXRzIGRhdGEgb2JqZWN0IGlzIGF1Z21lbnRlZCB3aXRoIHRoZSBuZXcgb25lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bm9kZX0gVGhlIG5ld2x5IGFkZGVkIG5vZGUgb3Igbm9kZSB3aXRoIGdpdmVuIGlkIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAqL1xuICAgIGFkZE5vZGU6IGFkZE5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGluayB0byB0aGUgZ3JhcGguIFRoZSBmdW5jdGlvbiBhbHdheXMgY3JlYXRlIGEgbmV3XG4gICAgICogbGluayBiZXR3ZWVuIHR3byBub2Rlcy4gSWYgb25lIG9mIHRoZSBub2RlcyBkb2VzIG5vdCBleGlzdHNcbiAgICAgKiBhIG5ldyBub2RlIGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbUlkIGxpbmsgc3RhcnQgbm9kZSBpZDtcbiAgICAgKiBAcGFyYW0gdG9JZCBsaW5rIGVuZCBub2RlIGlkO1xuICAgICAqIEBwYXJhbSBbZGF0YV0gYWRkaXRpb25hbCBkYXRhIHRvIGJlIHNldCBvbiB0aGUgbmV3IGxpbms7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtsaW5rfSBUaGUgbmV3bHkgY3JlYXRlZCBsaW5rXG4gICAgICovXG4gICAgYWRkTGluazogYWRkTGluayxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGluayBmcm9tIHRoZSBncmFwaC4gSWYgbGluayBkb2VzIG5vdCBleGlzdCBkb2VzIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluayAtIG9iamVjdCByZXR1cm5lZCBieSBhZGRMaW5rKCkgb3IgZ2V0TGlua3MoKSBtZXRob2RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBsaW5rIHdhcyByZW1vdmVkOyBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVtb3ZlTGluazogcmVtb3ZlTGluayxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbm9kZSB3aXRoIGdpdmVuIGlkIGZyb20gdGhlIGdyYXBoLiBJZiBub2RlIGRvZXMgbm90IGV4aXN0IGluIHRoZSBncmFwaFxuICAgICAqIGRvZXMgbm90aGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgbm9kZSdzIGlkZW50aWZpZXIgcGFzc2VkIHRvIGFkZE5vZGUoKSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgbm9kZSB3YXMgcmVtb3ZlZDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlbW92ZU5vZGU6IHJlbW92ZU5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG5vZGUgd2l0aCBnaXZlbiBpZGVudGlmaWVyLiBJZiBub2RlIGRvZXMgbm90IGV4aXN0IHVuZGVmaW5lZCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgcmVxdWVzdGVkIG5vZGUgaWRlbnRpZmllcjtcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge25vZGV9IGluIHdpdGggcmVxdWVzdGVkIGlkZW50aWZpZXIgb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2ggbm9kZSBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0Tm9kZTogZ2V0Tm9kZSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgbnVtYmVyIG9mIG5vZGVzIGluIHRoaXMgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBub2RlcyBpbiB0aGUgZ3JhcGguXG4gICAgICovXG4gICAgZ2V0Tm9kZXNDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vZGVzQ291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdG90YWwgbnVtYmVyIG9mIGxpbmtzIGluIHRoZSBncmFwaC5cbiAgICAgKi9cbiAgICBnZXRMaW5rc0NvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbGlua3MubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBsaW5rcyAoaW5ib3VuZCBhbmQgb3V0Ym91bmQpIGZyb20gdGhlIG5vZGUgd2l0aCBnaXZlbiBpZC5cbiAgICAgKiBJZiBub2RlIHdpdGggZ2l2ZW4gaWQgaXMgbm90IGZvdW5kIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZUlkIHJlcXVlc3RlZCBub2RlIGlkZW50aWZpZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFycmF5IG9mIGxpbmtzIGZyb20gYW5kIHRvIHJlcXVlc3RlZCBub2RlIGlmIHN1Y2ggbm9kZSBleGlzdHM7XG4gICAgICogICBvdGhlcndpc2UgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXRMaW5rczogZ2V0TGlua3MsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGNhbGxiYWNrIG9uIGVhY2ggbm9kZSBvZiB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uKG5vZGUpfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBpbnZva2VkLiBUaGUgZnVuY3Rpb25cbiAgICAgKiAgIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6IHZpc2l0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoTm9kZTogZm9yRWFjaE5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGNhbGxiYWNrIG9uIGV2ZXJ5IGxpbmtlZCAoYWRqYWNlbnQpIG5vZGUgdG8gdGhlIGdpdmVuIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgSWRlbnRpZmllciBvZiB0aGUgcmVxdWVzdGVkIG5vZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbihub2RlLCBsaW5rKX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFsbCBsaW5rZWQgbm9kZXMuXG4gICAgICogICBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIHR3byBwYXJhbWV0ZXJzOiBhZGphY2VudCBub2RlIGFuZCBsaW5rIG9iamVjdCBpdHNlbGYuXG4gICAgICogQHBhcmFtIG9yaWVudGVkIGlmIHRydWUgZ3JhcGggdHJlYXRlZCBhcyBvcmllbnRlZC5cbiAgICAgKi9cbiAgICBmb3JFYWNoTGlua2VkTm9kZTogZm9yRWFjaExpbmtlZE5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCBsaW5rcyBpbiB0aGUgZ3JhcGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24obGluayl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbGwgbGlua3MgaW4gdGhlIGdyYXBoLlxuICAgICAqICAgVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCBvbmUgcGFyYW1ldGVyOiBncmFwaCdzIGxpbmsgb2JqZWN0LlxuICAgICAqXG4gICAgICogTGluayBvYmplY3QgY29udGFpbnMgYXQgbGVhc3QgdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgICogIGZyb21JZCAtIG5vZGUgaWQgd2hlcmUgbGluayBzdGFydHM7XG4gICAgICogIHRvSWQgLSBub2RlIGlkIHdoZXJlIGxpbmsgZW5kcyxcbiAgICAgKiAgZGF0YSAtIGFkZGl0aW9uYWwgZGF0YSBwYXNzZWQgdG8gZ3JhcGguYWRkTGluaygpIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmb3JFYWNoTGluazogZm9yRWFjaExpbmssXG5cbiAgICAvKipcbiAgICAgKiBTdXNwZW5kIGFsbCBub3RpZmljYXRpb25zIGFib3V0IGdyYXBoIGNoYW5nZXMgdW50aWxcbiAgICAgKiBlbmRVcGRhdGUgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGJlZ2luVXBkYXRlOiBlbnRlck1vZGlmaWNhdGlvbixcblxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgYWxsIG5vdGlmaWNhdGlvbnMgYWJvdXQgZ3JhcGggY2hhbmdlcyBhbmQgZmlyZXNcbiAgICAgKiBncmFwaCAnY2hhbmdlZCcgZXZlbnQgaW4gY2FzZSB0aGVyZSBhcmUgYW55IHBlbmRpbmcgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBlbmRVcGRhdGU6IGV4aXRNb2RpZmljYXRpb24sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBub2RlcyBhbmQgbGlua3MgZnJvbSB0aGUgZ3JhcGguXG4gICAgICovXG4gICAgY2xlYXI6IGNsZWFyLFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyB3aGV0aGVyIHRoZXJlIGlzIGEgbGluayBiZXR3ZWVuIHR3byBub2Rlcy5cbiAgICAgKiBPcGVyYXRpb24gY29tcGxleGl0eSBpcyBPKG4pIHdoZXJlIG4gLSBudW1iZXIgb2YgbGlua3Mgb2YgYSBub2RlLlxuICAgICAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gaXMgc3lub25pbSBmb3IgZ2V0TGluaygpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBsaW5rIGlmIHRoZXJlIGlzIG9uZS4gbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaGFzTGluazogZ2V0TGluayxcblxuICAgIC8qKlxuICAgICAqIERldGVjdHMgd2hldGhlciB0aGVyZSBpcyBhIG5vZGUgd2l0aCBnaXZlbiBpZFxuICAgICAqIFxuICAgICAqIE9wZXJhdGlvbiBjb21wbGV4aXR5IGlzIE8oMSlcbiAgICAgKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIGlzIHN5bm9uaW0gZm9yIGdldE5vZGUoKVxuICAgICAqXG4gICAgICogQHJldHVybnMgbm9kZSBpZiB0aGVyZSBpcyBvbmU7IEZhbHN5IHZhbHVlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBoYXNOb2RlOiBnZXROb2RlLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBlZGdlIGJldHdlZW4gdHdvIG5vZGVzLlxuICAgICAqIE9wZXJhdGlvbiBjb21wbGV4aXR5IGlzIE8obikgd2hlcmUgbiAtIG51bWJlciBvZiBsaW5rcyBvZiBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbUlkIGxpbmsgc3RhcnQgaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b0lkIGxpbmsgZW5kIGlkZW50aWZpZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGxpbmsgaWYgdGhlcmUgaXMgb25lLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXRMaW5rOiBnZXRMaW5rXG4gIH07XG5cbiAgLy8gdGhpcyB3aWxsIGFkZCBgb24oKWAgYW5kIGBmaXJlKClgIG1ldGhvZHMuXG4gIGV2ZW50aWZ5KGdyYXBoUGFydCk7XG5cbiAgbW9uaXRvclN1YnNjcmliZXJzKCk7XG5cbiAgcmV0dXJuIGdyYXBoUGFydDtcblxuICBmdW5jdGlvbiBtb25pdG9yU3Vic2NyaWJlcnMoKSB7XG4gICAgdmFyIHJlYWxPbiA9IGdyYXBoUGFydC5vbjtcblxuICAgIC8vIHJlcGxhY2UgcmVhbCBgb25gIHdpdGggb3VyIHRlbXBvcmFyeSBvbiwgd2hpY2ggd2lsbCB0cmlnZ2VyIGNoYW5nZVxuICAgIC8vIG1vZGlmaWNhdGlvbiBtb25pdG9yaW5nOlxuICAgIGdyYXBoUGFydC5vbiA9IG9uO1xuXG4gICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICAvLyBub3cgaXQncyB0aW1lIHRvIHN0YXJ0IHRyYWNraW5nIHN0dWZmOlxuICAgICAgZ3JhcGhQYXJ0LmJlZ2luVXBkYXRlID0gZW50ZXJNb2RpZmljYXRpb24gPSBlbnRlck1vZGlmaWNhdGlvblJlYWw7XG4gICAgICBncmFwaFBhcnQuZW5kVXBkYXRlID0gZXhpdE1vZGlmaWNhdGlvbiA9IGV4aXRNb2RpZmljYXRpb25SZWFsO1xuICAgICAgcmVjb3JkTGlua0NoYW5nZSA9IHJlY29yZExpbmtDaGFuZ2VSZWFsO1xuICAgICAgcmVjb3JkTm9kZUNoYW5nZSA9IHJlY29yZE5vZGVDaGFuZ2VSZWFsO1xuXG4gICAgICAvLyB0aGlzIHdpbGwgcmVwbGFjZSBjdXJyZW50IGBvbmAgbWV0aG9kIHdpdGggcmVhbCBwdWIvc3ViIGZyb20gYGV2ZW50aWZ5YC5cbiAgICAgIGdyYXBoUGFydC5vbiA9IHJlYWxPbjtcbiAgICAgIC8vIGRlbGVnYXRlIHRvIHJlYWwgYG9uYCBoYW5kbGVyOlxuICAgICAgcmV0dXJuIHJlYWxPbi5hcHBseShncmFwaFBhcnQsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTGlua0NoYW5nZVJlYWwobGluaywgY2hhbmdlVHlwZSkge1xuICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICBsaW5rOiBsaW5rLFxuICAgICAgY2hhbmdlVHlwZTogY2hhbmdlVHlwZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTm9kZUNoYW5nZVJlYWwobm9kZSwgY2hhbmdlVHlwZSkge1xuICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgY2hhbmdlVHlwZTogY2hhbmdlVHlwZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTm9kZShub2RlSWQsIGRhdGEpIHtcbiAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBub2RlIGlkZW50aWZpZXInKTtcbiAgICB9XG5cbiAgICBlbnRlck1vZGlmaWNhdGlvbigpO1xuXG4gICAgdmFyIG5vZGUgPSBnZXROb2RlKG5vZGVJZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBub2RlID0gbmV3IE5vZGUobm9kZUlkLCBkYXRhKTtcbiAgICAgIG5vZGVzQ291bnQrKztcbiAgICAgIHJlY29yZE5vZGVDaGFuZ2Uobm9kZSwgJ2FkZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRhdGEgPSBkYXRhO1xuICAgICAgcmVjb3JkTm9kZUNoYW5nZShub2RlLCAndXBkYXRlJyk7XG4gICAgfVxuXG4gICAgbm9kZXNbbm9kZUlkXSA9IG5vZGU7XG5cbiAgICBleGl0TW9kaWZpY2F0aW9uKCk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlKG5vZGVJZCkge1xuICAgIHJldHVybiBub2Rlc1tub2RlSWRdO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlSWQpIHtcbiAgICB2YXIgbm9kZSA9IGdldE5vZGUobm9kZUlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlck1vZGlmaWNhdGlvbigpO1xuXG4gICAgdmFyIHByZXZMaW5rcyA9IG5vZGUubGlua3M7XG4gICAgaWYgKHByZXZMaW5rcykge1xuICAgICAgbm9kZS5saW5rcyA9IG51bGw7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJldkxpbmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlbW92ZUxpbmsocHJldkxpbmtzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUgbm9kZXNbbm9kZUlkXTtcbiAgICBub2Rlc0NvdW50LS07XG5cbiAgICByZWNvcmROb2RlQ2hhbmdlKG5vZGUsICdyZW1vdmUnKTtcblxuICAgIGV4aXRNb2RpZmljYXRpb24oKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cblxuICBmdW5jdGlvbiBhZGRMaW5rKGZyb21JZCwgdG9JZCwgZGF0YSkge1xuICAgIGVudGVyTW9kaWZpY2F0aW9uKCk7XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBnZXROb2RlKGZyb21JZCkgfHwgYWRkTm9kZShmcm9tSWQpO1xuICAgIHZhciB0b05vZGUgPSBnZXROb2RlKHRvSWQpIHx8IGFkZE5vZGUodG9JZCk7XG5cbiAgICB2YXIgbGluayA9IGNyZWF0ZUxpbmsoZnJvbUlkLCB0b0lkLCBkYXRhKTtcblxuICAgIGxpbmtzLnB1c2gobGluayk7XG5cbiAgICAvLyBUT0RPOiB0aGlzIGlzIG5vdCBjb29sLiBPbiBsYXJnZSBncmFwaHMgcG90ZW50aWFsbHkgd291bGQgY29uc3VtZSBtb3JlIG1lbW9yeS5cbiAgICBhZGRMaW5rVG9Ob2RlKGZyb21Ob2RlLCBsaW5rKTtcbiAgICBpZiAoZnJvbUlkICE9PSB0b0lkKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgYXJlIG5vdCBkdXBsaWNhdGluZyBsaW5rcyBmb3Igc2VsZi1sb29wc1xuICAgICAgYWRkTGlua1RvTm9kZSh0b05vZGUsIGxpbmspO1xuICAgIH1cblxuICAgIHJlY29yZExpbmtDaGFuZ2UobGluaywgJ2FkZCcpO1xuXG4gICAgZXhpdE1vZGlmaWNhdGlvbigpO1xuXG4gICAgcmV0dXJuIGxpbms7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaW5nbGVMaW5rKGZyb21JZCwgdG9JZCwgZGF0YSkge1xuICAgIHZhciBsaW5rSWQgPSBtYWtlTGlua0lkKGZyb21JZCwgdG9JZCk7XG4gICAgcmV0dXJuIG5ldyBMaW5rKGZyb21JZCwgdG9JZCwgZGF0YSwgbGlua0lkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaXF1ZUxpbmsoZnJvbUlkLCB0b0lkLCBkYXRhKSB7XG4gICAgLy8gVE9ETzogR2V0IHJpZCBvZiB0aGlzIG1ldGhvZC5cbiAgICB2YXIgbGlua0lkID0gbWFrZUxpbmtJZChmcm9tSWQsIHRvSWQpO1xuICAgIHZhciBpc011bHRpRWRnZSA9IG11bHRpRWRnZXMuaGFzT3duUHJvcGVydHkobGlua0lkKTtcbiAgICBpZiAoaXNNdWx0aUVkZ2UgfHwgZ2V0TGluayhmcm9tSWQsIHRvSWQpKSB7XG4gICAgICBpZiAoIWlzTXVsdGlFZGdlKSB7XG4gICAgICAgIG11bHRpRWRnZXNbbGlua0lkXSA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgc3VmZml4ID0gJ0AnICsgKCsrbXVsdGlFZGdlc1tsaW5rSWRdKTtcbiAgICAgIGxpbmtJZCA9IG1ha2VMaW5rSWQoZnJvbUlkICsgc3VmZml4LCB0b0lkICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExpbmsoZnJvbUlkLCB0b0lkLCBkYXRhLCBsaW5rSWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGlua3Mobm9kZUlkKSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlKG5vZGVJZCk7XG4gICAgcmV0dXJuIG5vZGUgPyBub2RlLmxpbmtzIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpbmsobGluaykge1xuICAgIGlmICghbGluaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaWR4ID0gaW5kZXhPZkVsZW1lbnRJbkFycmF5KGxpbmssIGxpbmtzKTtcbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGVudGVyTW9kaWZpY2F0aW9uKCk7XG5cbiAgICBsaW5rcy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIHZhciBmcm9tTm9kZSA9IGdldE5vZGUobGluay5mcm9tSWQpO1xuICAgIHZhciB0b05vZGUgPSBnZXROb2RlKGxpbmsudG9JZCk7XG5cbiAgICBpZiAoZnJvbU5vZGUpIHtcbiAgICAgIGlkeCA9IGluZGV4T2ZFbGVtZW50SW5BcnJheShsaW5rLCBmcm9tTm9kZS5saW5rcyk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgZnJvbU5vZGUubGlua3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRvTm9kZSkge1xuICAgICAgaWR4ID0gaW5kZXhPZkVsZW1lbnRJbkFycmF5KGxpbmssIHRvTm9kZS5saW5rcyk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdG9Ob2RlLmxpbmtzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlY29yZExpbmtDaGFuZ2UobGluaywgJ3JlbW92ZScpO1xuXG4gICAgZXhpdE1vZGlmaWNhdGlvbigpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5rKGZyb21Ob2RlSWQsIHRvTm9kZUlkKSB7XG4gICAgLy8gVE9ETzogVXNlIHNvcnRlZCBsaW5rcyB0byBzcGVlZCB0aGlzIHVwXG4gICAgdmFyIG5vZGUgPSBnZXROb2RlKGZyb21Ob2RlSWQpLFxuICAgICAgaTtcbiAgICBpZiAoIW5vZGUgfHwgIW5vZGUubGlua3MpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmxpbmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluayA9IG5vZGUubGlua3NbaV07XG4gICAgICBpZiAobGluay5mcm9tSWQgPT09IGZyb21Ob2RlSWQgJiYgbGluay50b0lkID09PSB0b05vZGVJZCkge1xuICAgICAgICByZXR1cm4gbGluaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDsgLy8gbm8gbGluay5cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGVudGVyTW9kaWZpY2F0aW9uKCk7XG4gICAgZm9yRWFjaE5vZGUoZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmVtb3ZlTm9kZShub2RlLmlkKTtcbiAgICB9KTtcbiAgICBleGl0TW9kaWZpY2F0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoTGluayhjYWxsYmFjaykge1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbGlua3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2FsbGJhY2sobGlua3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckVhY2hMaW5rZWROb2RlKG5vZGVJZCwgY2FsbGJhY2ssIG9yaWVudGVkKSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlKG5vZGVJZCk7XG5cbiAgICBpZiAobm9kZSAmJiBub2RlLmxpbmtzICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKG9yaWVudGVkKSB7XG4gICAgICAgIHJldHVybiBmb3JFYWNoT3JpZW50ZWRMaW5rKG5vZGUubGlua3MsIG5vZGVJZCwgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZvckVhY2hOb25PcmllbnRlZExpbmsobm9kZS5saW5rcywgbm9kZUlkLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yRWFjaE5vbk9yaWVudGVkTGluayhsaW5rcywgbm9kZUlkLCBjYWxsYmFjaykge1xuICAgIHZhciBxdWl0RmFzdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluayA9IGxpbmtzW2ldO1xuICAgICAgdmFyIGxpbmtlZE5vZGVJZCA9IGxpbmsuZnJvbUlkID09PSBub2RlSWQgPyBsaW5rLnRvSWQgOiBsaW5rLmZyb21JZDtcblxuICAgICAgcXVpdEZhc3QgPSBjYWxsYmFjayhub2Rlc1tsaW5rZWROb2RlSWRdLCBsaW5rKTtcbiAgICAgIGlmIChxdWl0RmFzdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQ2xpZW50IGRvZXMgbm90IG5lZWQgbW9yZSBpdGVyYXRpb25zLiBCcmVhayBub3cuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yRWFjaE9yaWVudGVkTGluayhsaW5rcywgbm9kZUlkLCBjYWxsYmFjaykge1xuICAgIHZhciBxdWl0RmFzdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluayA9IGxpbmtzW2ldO1xuICAgICAgaWYgKGxpbmsuZnJvbUlkID09PSBub2RlSWQpIHtcbiAgICAgICAgcXVpdEZhc3QgPSBjYWxsYmFjayhub2Rlc1tsaW5rLnRvSWRdLCBsaW5rKTtcbiAgICAgICAgaWYgKHF1aXRGYXN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIENsaWVudCBkb2VzIG5vdCBuZWVkIG1vcmUgaXRlcmF0aW9ucy4gQnJlYWsgbm93LlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gd2Ugd2lsbCBub3QgZmlyZSBhbnl0aGluZyB1bnRpbCB1c2VycyBvZiB0aGlzIGxpYnJhcnkgZXhwbGljaXRseSBjYWxsIGBvbigpYFxuICAvLyBtZXRob2QuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gIC8vIEVudGVyLCBFeGl0IG1vZGlmaWNhdGlvbiBhbGxvd3MgYnVsayBncmFwaCB1cGRhdGVzIHdpdGhvdXQgZmlyaW5nIGV2ZW50cy5cbiAgZnVuY3Rpb24gZW50ZXJNb2RpZmljYXRpb25SZWFsKCkge1xuICAgIHN1c3BlbmRFdmVudHMgKz0gMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4aXRNb2RpZmljYXRpb25SZWFsKCkge1xuICAgIHN1c3BlbmRFdmVudHMgLT0gMTtcbiAgICBpZiAoc3VzcGVuZEV2ZW50cyA9PT0gMCAmJiBjaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGdyYXBoUGFydC5maXJlKCdjaGFuZ2VkJywgY2hhbmdlcyk7XG4gICAgICBjaGFuZ2VzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUl0ZXJhdG9yKCkge1xuICAgIC8vIE9iamVjdC5rZXlzIGl0ZXJhdG9yIGlzIDEuM3ggZmFzdGVyIHRoYW4gYGZvciBpbmAgbG9vcC5cbiAgICAvLyBTZWUgYGh0dHBzOi8vZ2l0aHViLmNvbS9hbnZha2EvbmdyYXBoLmdyYXBoL3RyZWUvYmVuY2gtZm9yLWluLXZzLW9iai1rZXlzYFxuICAgIC8vIGJyYW5jaCBmb3IgcGVyZiB0ZXN0XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzID8gb2JqZWN0S2V5c0l0ZXJhdG9yIDogZm9ySW5JdGVyYXRvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9iamVjdEtleXNJdGVyYXRvcihjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGVzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChjYWxsYmFjayhub2Rlc1trZXlzW2ldXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIGNsaWVudCBkb2Vzbid0IHdhbnQgdG8gcHJvY2VlZC4gUmV0dXJuLlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckluSXRlcmF0b3IoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub2RlO1xuXG4gICAgZm9yIChub2RlIGluIG5vZGVzKSB7XG4gICAgICBpZiAoY2FsbGJhY2sobm9kZXNbbm9kZV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBjbGllbnQgZG9lc24ndCB3YW50IHRvIHByb2NlZWQuIFJldHVybi5cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gbmVlZCB0aGlzIGZvciBvbGQgYnJvd3NlcnMuIFNob3VsZCB0aGlzIGJlIGEgc2VwYXJhdGUgbW9kdWxlP1xuZnVuY3Rpb24gaW5kZXhPZkVsZW1lbnRJbkFycmF5KGVsZW1lbnQsIGFycmF5KSB7XG4gIGlmICghYXJyYXkpIHJldHVybiAtMTtcblxuICBpZiAoYXJyYXkuaW5kZXhPZikge1xuICAgIHJldHVybiBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aCxcbiAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGlmIChhcnJheVtpXSA9PT0gZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEludGVybmFsIHN0cnVjdHVyZSB0byByZXByZXNlbnQgbm9kZTtcbiAqL1xuZnVuY3Rpb24gTm9kZShpZCwgZGF0YSkge1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMubGlua3MgPSBudWxsO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5mdW5jdGlvbiBhZGRMaW5rVG9Ob2RlKG5vZGUsIGxpbmspIHtcbiAgaWYgKG5vZGUubGlua3MpIHtcbiAgICBub2RlLmxpbmtzLnB1c2gobGluayk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5saW5rcyA9IFtsaW5rXTtcbiAgfVxufVxuXG4vKipcbiAqIEludGVybmFsIHN0cnVjdHVyZSB0byByZXByZXNlbnQgbGlua3M7XG4gKi9cbmZ1bmN0aW9uIExpbmsoZnJvbUlkLCB0b0lkLCBkYXRhLCBpZCkge1xuICB0aGlzLmZyb21JZCA9IGZyb21JZDtcbiAgdGhpcy50b0lkID0gdG9JZDtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5pZCA9IGlkO1xufVxuXG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgdmFyIGhhc2ggPSAwLCBpLCBjaHIsIGxlbjtcbiAgaWYgKHN0ci5sZW5ndGggPT0gMCkgcmV0dXJuIGhhc2g7XG4gIGZvciAoaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNociAgID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGNocjtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG4gIHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBtYWtlTGlua0lkKGZyb21JZCwgdG9JZCkge1xuICByZXR1cm4gZnJvbUlkLnRvU3RyaW5nKCkgKyAn8J+RiSAnICsgdG9JZC50b1N0cmluZygpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval("module.exports = function(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmdyYXBoLmV2ZW50cy9pbmRleC5qcz8wMGM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtCQUFrQixnQ0FBZ0M7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2Qjs7QUFFbEQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN1YmplY3QpIHtcbiAgdmFsaWRhdGVTdWJqZWN0KHN1YmplY3QpO1xuXG4gIHZhciBldmVudHNTdG9yYWdlID0gY3JlYXRlRXZlbnRzU3RvcmFnZShzdWJqZWN0KTtcbiAgc3ViamVjdC5vbiA9IGV2ZW50c1N0b3JhZ2Uub247XG4gIHN1YmplY3Qub2ZmID0gZXZlbnRzU3RvcmFnZS5vZmY7XG4gIHN1YmplY3QuZmlyZSA9IGV2ZW50c1N0b3JhZ2UuZmlyZTtcbiAgcmV0dXJuIHN1YmplY3Q7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVFdmVudHNTdG9yYWdlKHN1YmplY3QpIHtcbiAgLy8gU3RvcmUgYWxsIGV2ZW50IGxpc3RlbmVycyB0byB0aGlzIGhhc2guIEtleSBpcyBldmVudCBuYW1lLCB2YWx1ZSBpcyBhcnJheVxuICAvLyBvZiBjYWxsYmFjayByZWNvcmRzLlxuICAvL1xuICAvLyBBIGNhbGxiYWNrIHJlY29yZCBjb25zaXN0cyBvZiBjYWxsYmFjayBmdW5jdGlvbiBhbmQgaXRzIG9wdGlvbmFsIGNvbnRleHQ6XG4gIC8vIHsgJ2V2ZW50TmFtZScgPT4gW3tjYWxsYmFjazogZnVuY3Rpb24sIGN0eDogb2JqZWN0fV0gfVxuICB2YXIgcmVnaXN0ZXJlZEV2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYW5kbGVycyA9IHJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXTtcbiAgICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgICAgaGFuZGxlcnMgPSByZWdpc3RlcmVkRXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXJzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY3R4OiBjdHh9KTtcblxuICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfSxcblxuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciB3YW50VG9SZW1vdmVBbGwgPSAodHlwZW9mIGV2ZW50TmFtZSA9PT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgaWYgKHdhbnRUb1JlbW92ZUFsbCkge1xuICAgICAgICAvLyBLaWxsaW5nIG9sZCBldmVudHMgc3RvcmFnZSBzaG91bGQgYmUgZW5vdWdoIGluIHRoaXMgY2FzZTpcbiAgICAgICAgcmVnaXN0ZXJlZEV2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVnaXN0ZXJlZEV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgIHZhciBkZWxldGVBbGxDYWxsYmFja3NGb3JFdmVudCA9ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpO1xuICAgICAgICBpZiAoZGVsZXRlQWxsQ2FsbGJhY2tzRm9yRXZlbnQpIHtcbiAgICAgICAgICBkZWxldGUgcmVnaXN0ZXJlZEV2ZW50c1tldmVudE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjYWxsYmFja3MgPSByZWdpc3RlcmVkRXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3NbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH0sXG5cbiAgICBmaXJlOiBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gcmVnaXN0ZXJlZEV2ZW50c1tldmVudE5hbWVdO1xuICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJlQXJndW1lbnRzO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZpcmVBcmd1bWVudHMgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrSW5mbyA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgY2FsbGJhY2tJbmZvLmNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrSW5mby5jdHgsIGZpcmVBcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3ViamVjdChzdWJqZWN0KSB7XG4gIGlmICghc3ViamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRpZnkgY2Fubm90IHVzZSBmYWxzeSBvYmplY3QgYXMgZXZlbnRzIHN1YmplY3QnKTtcbiAgfVxuICB2YXIgcmVzZXJ2ZWRXb3JkcyA9IFsnb24nLCAnZmlyZScsICdvZmYnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNlcnZlZFdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHN1YmplY3QuaGFzT3duUHJvcGVydHkocmVzZXJ2ZWRXb3Jkc1tpXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmplY3QgY2Fubm90IGJlIGV2ZW50aWZpZWQsIHNpbmNlIGl0IGFscmVhZHkgaGFzIHByb3BlcnR5ICdcIiArIHJlc2VydmVkV29yZHNbaV0gKyBcIidcIik7XG4gICAgfVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,exports){eval("module.exports = save;\n\nfunction save(graph, customNodeTransform, customLinkTransform) {\n  // Object contains `nodes` and `links` arrays.\n  var result = {\n    nodes: [],\n    links: []\n  };\n\n  var nodeTransform = customNodeTransform || defaultTransformForNode;\n  var linkTransform = customLinkTransform || defaultTransformForLink;\n\n  graph.forEachNode(saveNode);\n  graph.forEachLink(saveLink);\n\n  return JSON.stringify(result);\n\n  function saveNode(node) {\n    // Each node of the graph is processed to take only required fields\n    // `id` and `data`\n    result.nodes.push(nodeTransform(node));\n  }\n\n  function saveLink(link) {\n    // Each link of the graph is also processed to take `fromId`, `toId` and\n    // `data`\n    result.links.push(linkTransform(link));\n  }\n\n  function defaultTransformForNode(node) {\n    var result = {\n      id: node.id\n    };\n    // We don't want to store undefined fields when it's not necessary:\n    if (node.data !== undefined) {\n      result.data = node.data;\n    }\n\n    return result;\n  }\n\n  function defaultTransformForLink(link) {\n    var result = {\n      fromId: link.fromId,\n      toId: link.toId,\n    };\n\n    if (link.data !== undefined) {\n      result.data = link.data;\n    }\n\n    return result;\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmdyYXBoLnRvanNvbi9pbmRleC5qcz8zNzliIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gc2F2ZTtcblxuZnVuY3Rpb24gc2F2ZShncmFwaCwgY3VzdG9tTm9kZVRyYW5zZm9ybSwgY3VzdG9tTGlua1RyYW5zZm9ybSkge1xuICAvLyBPYmplY3QgY29udGFpbnMgYG5vZGVzYCBhbmQgYGxpbmtzYCBhcnJheXMuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgbm9kZXM6IFtdLFxuICAgIGxpbmtzOiBbXVxuICB9O1xuXG4gIHZhciBub2RlVHJhbnNmb3JtID0gY3VzdG9tTm9kZVRyYW5zZm9ybSB8fCBkZWZhdWx0VHJhbnNmb3JtRm9yTm9kZTtcbiAgdmFyIGxpbmtUcmFuc2Zvcm0gPSBjdXN0b21MaW5rVHJhbnNmb3JtIHx8IGRlZmF1bHRUcmFuc2Zvcm1Gb3JMaW5rO1xuXG4gIGdyYXBoLmZvckVhY2hOb2RlKHNhdmVOb2RlKTtcbiAgZ3JhcGguZm9yRWFjaExpbmsoc2F2ZUxpbmspO1xuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuXG4gIGZ1bmN0aW9uIHNhdmVOb2RlKG5vZGUpIHtcbiAgICAvLyBFYWNoIG5vZGUgb2YgdGhlIGdyYXBoIGlzIHByb2Nlc3NlZCB0byB0YWtlIG9ubHkgcmVxdWlyZWQgZmllbGRzXG4gICAgLy8gYGlkYCBhbmQgYGRhdGFgXG4gICAgcmVzdWx0Lm5vZGVzLnB1c2gobm9kZVRyYW5zZm9ybShub2RlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzYXZlTGluayhsaW5rKSB7XG4gICAgLy8gRWFjaCBsaW5rIG9mIHRoZSBncmFwaCBpcyBhbHNvIHByb2Nlc3NlZCB0byB0YWtlIGBmcm9tSWRgLCBgdG9JZGAgYW5kXG4gICAgLy8gYGRhdGFgXG4gICAgcmVzdWx0LmxpbmtzLnB1c2gobGlua1RyYW5zZm9ybShsaW5rKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtRm9yTm9kZShub2RlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGlkOiBub2RlLmlkXG4gICAgfTtcbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIHN0b3JlIHVuZGVmaW5lZCBmaWVsZHMgd2hlbiBpdCdzIG5vdCBuZWNlc3Nhcnk6XG4gICAgaWYgKG5vZGUuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHQuZGF0YSA9IG5vZGUuZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybUZvckxpbmsobGluaykge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBmcm9tSWQ6IGxpbmsuZnJvbUlkLFxuICAgICAgdG9JZDogbGluay50b0lkLFxuICAgIH07XG5cbiAgICBpZiAobGluay5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdC5kYXRhID0gbGluay5kYXRhO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ngraph.graph/index.js\nvar ngraph_graph = __webpack_require__(0);\nvar ngraph_graph_default = /*#__PURE__*/__webpack_require__.n(ngraph_graph);\n\n// CONCATENATED MODULE: ./src/EdgeKeys.js\nclass EdgeKeys {\n\n  constructor () {\n    this.keys = []\n  }\n\n  findKeyPosition (edgekey, p) {\n    let lo = 0\n    let hi = this.keys.length\n    while (lo < hi) {\n      const mid = Math.floor((lo + hi) / 2)\n      if (edgekey.isLessThanOtherEdgeKey(this.keys[mid])) hi = mid\n      else lo = mid + 1\n    }\n    return lo\n  }\n\n  addKey (edgekey, p) {\n    const lo = this.findKeyPosition(edgekey)\n    this.keys.splice(lo, 0, edgekey)\n  }\n}\n\n// CONCATENATED MODULE: ./src/Point.js\n\n\nclass Point_Point {\n\n  constructor (coords, polygonID) {\n    if (polygonID === null) polygonID = -1\n    this.x = coords[0]\n    this.y = coords[1]\n    this.polygonID = polygonID\n    this.edges = []\n    this.prevPoint = null\n    this.nextPoint = null\n  }\n\n  isPointEqual (otherPoint) {\n    return this.x === otherPoint.x && this.y === otherPoint.y\n  }\n\n  angleToPoint (otherPoint) {\n    if (this.isPointEqual(otherPoint)) return 0\n    const dx = otherPoint.x - this.x\n    const dy = otherPoint.y - this.y\n    if (dx === 0) dy < 1 ? pi1 : pi2\n    if (dy === 0) dx < 0 ? Math.PI : 0\n    if (dx < 0) return Math.PI + Math.atan(dy / dx)\n    if (dy < 0) return 2 * Math.PI + Math.atan(dy / dx)\n    return Math.atan(dy / dx)\n  }\n}\n\n// CONCATENATED MODULE: ./src/utils.js\n\n\nconst pi1 = Math.PI * 3 / 2\nconst pi2 = Math.PI / 2\n\nconst INF = 10000\nconst COLIN_TOLERANCE = 13\nconst T = Math.pow(10, COLIN_TOLERANCE)\nconst T2 = Math.pow(10.0, COLIN_TOLERANCE)\n\nfunction edgeIntersect (p1, q1, edge) {\n  const p2 = edge.p1\n  const q2 = edge.p2\n  const o1 = ccw(p1, q1, p2)\n  const o2 = ccw(p1, q1, q2)\n  const o3 = ccw(p2, q2, p1)\n  const o4 = ccw(p2, q2, q1)\n  if (o1 !== o2 && o3 !== o4) return true\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true\n  return false\n}\n\nfunction ccw (a, b, c) {\n  const area = Math.round(((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) * T) / T2\n  if (area > 0) return 1\n  if (area < 0) return -1\n  return 0\n}\n\nfunction onSegment (p, q, r) {\n  if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x)) {\n    if (q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) return true\n  }\n  return false\n}\n\nfunction utils_angle2 (p1, p2, p3) {\n  const a = Math.pow((p3.x - p2.x), 2) + Math.pow((p3.y - p2.y), 2)\n  const b = Math.pow((p3.x - p1.x), 2) + Math.pow((p3.y - p1.y), 2)\n  const c = Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2)\n  return Math.acos((a + c - b) / (2 * Math.sqrt(a) * Math.sqrt(c)))\n}\n\nfunction pointEdgeDistance (p1, p2, edge) {\n  const ip = intersectPoint(p1, p2, edge)\n  return ip !== null ? calcEdgeDistance(p1, ip) : 0\n}\n\nfunction intersectPoint (p1, p2, edge) {\n  if (edge.containsPoint(p1)) return p1\n  if (edge.containsPoint(p2)) return p2\n  if (edge.p1.x === edge.p2.x) {\n    if (p1.x === p2.x) return null\n    const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n    const intersectX = edge.p1.x\n    const intersectY = pslope * (intersectX - p1.x) + p1.y\n    return new Point_Point([intersectX, intersectY], null)\n  }\n  if (p1.x === p2.x) {\n    const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n    const intersectX = p1.x\n    const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n    return new Point_Point([intersectX, intersectY], null)\n  }\n\n  const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n  const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n\n  if (pslope === eslope) return null\n  const intersectX = (eslope * edge.p1.x - pslope * p1.x + p1.y - edge.p1.y) / (eslope - pslope)\n  const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n  return new Point_Point([intersectX, intersectY], null)\n}\n\nfunction calcEdgeDistance (p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2))\n}\n\n// CONCATENATED MODULE: ./src/EdgeKey.js\n\n\nclass EdgeKey_EdgeKey {\n\n  constructor (p1, p2, edge) {\n    this.p1 = p1\n    this.p2 = p2\n    this.edge = edge\n  }\n\n  isLessThanOtherEdgeKey (otherEdgeKey) {\n    if (this.matchesOtherKey(otherEdgeKey)) return false\n    if (!edgeIntersect(this.p1, this.p2, otherEdgeKey.edge)) return true\n    const selfDistance = pointEdgeDistance(this.p1, this.p2, this.edge)\n    const otherDistance = pointEdgeDistance(this.p1, this.p2, otherEdgeKey.edge)\n    if (selfDistance > otherDistance) return false\n    if (selfDistance < otherDistance) return true\n    if (selfDistance === otherDistance) {\n      let samePoint = null\n      if (otherEdgeKey.edge.containsPoint(this.edge.p1)) samePoint = this.edge.p1\n      // else if (otherEdgeKey.edge.containsPoint(this.edge.p2)) samePoint = this.edge.p2\n      else samePoint = this.edge.p2\n      const aslf = utils_angle2(this.p1, this.p2, this.edge.getOtherPointInEdge(samePoint))\n      const aot = utils_angle2(this.p1, this.p2, otherEdgeKey.edge.getOtherPointInEdge(samePoint))\n      if (aslf < aot) return true\n      return false\n    }\n  }\n\n  matchesOtherKey (otherKey) {\n    return this.edge.areEdgesEqual(otherKey.edge)\n  }\n\n}\n\n// CONCATENATED MODULE: ./src/Edge.js\nclass Edge {\n  constructor (p1, p2) {\n    this.p1 = p1\n    this.p2 = p2\n\n    p1.edges.push(this)\n    p2.edges.push(this)\n  }\n\n  getOtherPointInEdge (point) {\n    return this.p1.isPointEqual(point) ? this.p2 : this.p1\n  }\n\n  areEdgesEqual (otherEdge) {\n    if (this.p1.isPointEqual(otherEdge.p1) && this.p2.isPointEqual(otherEdge.p2)) return true\n    if (this.p1.isPointEqual(otherEdge.p2) && this.p2.isPointEqual(otherEdge.p1)) return true\n    return false\n  }\n\n  containsPoint (point) {\n    if (this.p1.isPointEqual(point) || this.p2.isPointEqual(point)) return true\n    return false\n  }\n}\n\n// CONCATENATED MODULE: ./src/setupStructure.js\n\n\n\nfunction setupStructure (geojson, edges, points, polygons) {\n  const geom = geojson.type === 'Feature' ? geojson.geometry : geojson\n\n  let coords = geom.coordinates\n\n  // standardise the input\n  if (geom.type === 'Polygon') coords = [coords]\n\n  for (let i = 0; i < coords.length; i++) {\n    const contour = []\n    polygons.push(contour)\n\n    for (let ii = 0; ii < coords[i].length; ii++) {\n      let prevPoint = new Point_Point(coords[i][ii][0], i)\n      let currentPoint = new Point_Point(coords[i][ii][1], i)\n      prevPoint.nextPoint = currentPoint\n      let nextPoint = new Point_Point(coords[i][ii][2], i)\n      linkPoints(prevPoint, currentPoint, nextPoint)\n\n      points.push(prevPoint)\n\n      let prevEdge = new Edge(prevPoint, currentPoint) // eslint-disable-line\n      edges.push(prevEdge)\n      contour.push(prevEdge)\n\n      // Save me for later\n      const firstPoint = prevPoint\n\n      prevPoint = currentPoint\n      currentPoint = nextPoint\n\n      for (let iii = 2; iii < coords[i][ii].length - 2; iii++) {\n        points.push(prevPoint)\n\n        nextPoint = new Point_Point(coords[i][ii][iii + 1], i)\n\n        linkPoints(prevPoint, currentPoint, nextPoint)\n\n        const e = new Edge(prevPoint, currentPoint) // eslint-disable-line\n\n        edges.push(e)\n        contour.push(e)\n\n        prevPoint = currentPoint\n        currentPoint = nextPoint\n        prevEdge = e\n      }\n\n      linkPoints(prevPoint, currentPoint, firstPoint)\n\n      const secondLastEdge = new Edge(prevEdge.p2, currentPoint)\n\n      edges.push(secondLastEdge)\n      contour.push(secondLastEdge)\n\n      const lastEdge = new Edge(currentPoint, firstPoint) // eslint-disable-line\n      linkPoints(currentPoint, firstPoint, firstPoint.nextPoint)\n\n      edges.push(lastEdge)\n      contour.push(lastEdge)\n\n      points.push(prevPoint)\n      points.push(nextPoint)\n    }\n  }\n}\n\nfunction linkPoints (prevPoint, currentPoint, nextPoint) {\n  currentPoint.prevPoint = prevPoint\n  currentPoint.nextPoint = nextPoint\n}\n\n// CONCATENATED MODULE: ./src/debug.js\n\nfunction _renderSortedPoints (point, sortedPoints) {\n  const map = window.map\n  var sortedPointsLg = null\n\n  L.NumberedDivIcon = createNumberDiv()\n\n  setCurrentPoint(point)\n\n  if (sortedPointsLg === null) sortedPointsLg = L.layerGroup([]).addTo(map)\n  else sortedPointsLg.clearLayers()\n  sortedPoints.forEach((p, index) => {\n    return L.marker([p.y, p.x], {\n      color: 'black',\n      icon: new L.NumberedDivIcon({ number: index.toString() })\n    }).addTo(sortedPointsLg)\n  })\n\n  // debugger\n}\n\nfunction _renderOpenEdges (point, edges) {\n  const map = window.map\n  const currentPoint = L.circleMarker([point.y, point.x], {\n    radius: 20,\n    color: 'green'\n  }).addTo(map)\n  var openEdges = L.layerGroup([]).addTo(map)\n\n  edges.forEach((e, index) => {\n    L.polyline([[e.edge.p1.y, e.edge.p1.x], [e.edge.p2.y, e.edge.p2.x]], {\n      color: 'red'\n    }).addTo(openEdges)\n  })\n\n  // debugger\n  openEdges.clearLayers()\n  map.removeLayer(currentPoint)\n}\n\nfunction setCurrentPoint (point) {\n  const map = window.map\n  let currentPoint = null\n\n  if (currentPoint !== null) map.removeLayer(currentPoint)\n\n  currentPoint = L.circleMarker([point.y, point.x], {\n    radius: 20,\n    color: 'green'\n  }).addTo(map)\n\n}\n\nfunction createNumberDiv () {\n  return L.Icon.extend({\n    options: {\n      number: '',\n      iconSize: new L.Point(25, 25),\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function () {\n      var div = document.createElement('div')\n      var numdiv = document.createElement('div')\n      numdiv.setAttribute('class', 'number')\n      numdiv.innerHTML = this.options['number'] || ''\n      div.appendChild(numdiv)\n      this._setIconStyles(div, 'icon')\n      return div\n    }\n  })\n}\n\n\n// CONCATENATED MODULE: ./src/createGraphFromGeoJson.js\n\n\n\n\n\n\n //eslint-disable-line\n\nfunction createGraphFromGeoJson (geojson) {\n\n  const points = []\n  const edges = []\n  const polygons = []\n\n  setupStructure(geojson, edges, points, polygons)\n\n  return processGraph()\n\n  function processGraph () {\n    const g = ngraph_graph_default()()\n    const pointsLen = points.length\n    const clonedPoints = clonePoints()\n\n    for (var i = 0; i < pointsLen; i++) {\n      const p = points[i]\n      const prevPoint = p.prevPoint\n      const nextPoint = p.nextPoint\n\n      sortPoints(p, clonedPoints)\n      // _renderSortedPoints(p, clonedPoints)\n\n      const openEdges = new EdgeKeys()\n      const pointInf = new Point_Point([INF, p.y], null)\n      for (let ii = 0; ii < pointsLen; ii++) {\n        const e = edges[ii]\n        if (e.containsPoint(p)) continue\n        if (edgeIntersect(p, pointInf, e)) {\n          if (onSegment(p, e.p1, pointInf) || onSegment(p, e.p2, pointInf)) continue\n          openEdges.addKey(new EdgeKey_EdgeKey(p, pointInf, e))\n        }\n      }\n      // _renderOpenEdges(p, openEdges.keys)\n\n      const visible = []\n      let prev = null\n      let prevVisible = null\n\n      for (let ii = 0; ii < pointsLen; ii++) {\n        const p2 = clonedPoints[ii]\n        if (p2.isPointEqual(p)) continue\n        if (p.angleToPoint(p2) > Math.pi) break\n\n        if (openEdges.keys.length > 0) {\n          for (let iii = 0; iii < p2.edges.length; iii++) {\n            const e = p2.edges[iii]\n            if (ccw(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n              const k = new EdgeKey_EdgeKey(p, p2, e)\n              const index = openEdges.findKeyPosition(k) - 1\n              if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n                openEdges.keys.splice(index, 1)\n              }\n            }\n          }\n        }\n\n        let isVisible = false\n        if (prev === null || ccw(p, prev, p2) !== 0 || !onSegment(p, prev, p2)) {\n          if (openEdges.keys.length === 0) {\n            isVisible = true\n          } else if (!edgeIntersect(p, p2, openEdges.keys[0].edge)) {\n            isVisible = true\n          }\n        } else if (!prevVisible) {\n          isVisible = false\n        } else {\n          isVisible = true\n          for (let iii = 0; iii < openEdges.keys.length; iii++) {\n            const e = openEdges.keys[iii]\n            if (!e.edge.containsPoint(prev) && edgeIntersect(prev, p2, e.edge)) {\n              isVisible = false\n              break\n            }\n          }\n          if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n        }\n\n        const isInAdjacentPoints = p2.isPointEqual(prevPoint) || p2.isPointEqual(nextPoint)\n        if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n        if (isVisible) visible.push(p2)\n\n        for (let iii = 0; iii < p2.edges.length; iii++) {\n          const e = p2.edges[iii]\n          if (!e.containsPoint(p) && ccw(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n            const k = new EdgeKey_EdgeKey(p, p2, e)\n            openEdges.addKey(k)\n          }\n        }\n\n        prev = p2\n        prevVisible = isVisible\n      }\n\n      const nodeId = createNodeId(p)\n      g.addNode(nodeId, { x: p.x, y: p.y })\n\n      for (var ii = 0; ii < visible.length; ii++) {\n        const otherNodeId = createNodeId(visible[ii])\n        g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n        g.addLink(nodeId, otherNodeId)\n      }\n    }\n    return g\n  }\n\n  function createNodeId (p) {\n    return p.x + ',' + p.y\n  }\n\n  function clonePoints () {\n    return points.slice(0)\n  }\n\n  function sortPoints (point, clonedPoints) {\n    clonedPoints.sort((a, b) => {\n      const angle1 = point.angleToPoint(a)\n      const angle2 = point.angleToPoint(b)\n      if (angle1 < angle2) return -1\n      if (angle1 > angle2) return 1\n      const dist1 = calcEdgeDistance(point, a)\n      const dist2 = calcEdgeDistance(point, b)\n      if (dist1 < dist2) return -1\n      if (dist1 > dist2) return 1\n      return 0\n    })\n  }\n\n  function edgeInPolygon (p1, p2) {\n    if (p1.polygonID !== p2.polygonID) return false\n    if (p1.polygonID === -1 || p2.polygonID === -1) return false\n    const midPoint = new Point_Point([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2], null)\n    return polygonCrossing(midPoint, polygons[p1.polygonID])\n  }\n\n  function polygonCrossing (p1, polyEdges) {\n    const p2 = new Point_Point([INF, p1.y], null)\n    let intersectCount = 0\n    let coFlag = false\n    let coDir = 0\n\n    for (let i = 0; i < polyEdges.length; i++) {\n      const e = polyEdges[i]\n      if (p1.y < e.p1.y && p1.y < e.p2.y) continue\n      if (p1.y > e.p1.y && p1.y > e.p2.y) continue\n      const co0 = (ccw(p1, e.p1, p2) === 0) && (e.p1.x > p1.x)\n      const co1 = (ccw(p1, e.p2, p2) === 0) && (e.p2.x > p1.x)\n      const coPoint = co0 ? e.p1 : e.p2\n      if (co0 || co1) {\n        coDir = e.getOtherPointInEdge(coPoint).y > p1.y ? coDir++ : coDir--\n        if (coFlag) {\n          if (coDir === 0) intersectCount++\n          coFlag = false\n          coDir = 0\n        } else {\n          coFlag = true\n        }\n      } else if (edgeIntersect(p1, p2, e)) {\n        intersectCount++\n      }\n    }\n    if (intersectCount % 2 === 0) return false\n    return true\n  }\n\n}\n\n// CONCATENATED MODULE: ./src/main.js\n\n\n// CONCATENATED MODULE: ./debug/src/graphCreation.worker.js\n\nvar tojson = __webpack_require__(2)\n\nself.addEventListener('message', function (e) {\n  const outGraph = createGraphFromGeoJson(e.data)\n  const jsonContent = tojson(outGraph)\n\n  self.postMessage(jsonContent)\n}, false)\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRnZUtleXMuanM/ODM4ZiIsIndlYnBhY2s6Ly8vLi9zcmMvUG9pbnQuanM/YzYxYiIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMuanM/MDI1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvRWRnZUtleS5qcz84NmE1Iiwid2VicGFjazovLy8uL3NyYy9FZGdlLmpzPzQwMGIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHVwU3RydWN0dXJlLmpzPzQxYTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlYnVnLmpzPzBkODMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NyZWF0ZUdyYXBoRnJvbUdlb0pzb24uanM/MjczYyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Iiwid2VicGFjazovLy8uL2RlYnVnL3NyYy9ncmFwaENyZWF0aW9uLndvcmtlci5qcz9hOTEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJrQzs7QUFFM0IsTUFBTSxXQUFLOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUcsR0FBRyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUIrQjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sU0FBUyxZQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFLO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTs7O0FDL0VrRTs7QUFFM0QsTUFBTSxlQUFPOztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGFBQWE7QUFDdEIseUJBQXlCLGlCQUFpQjtBQUMxQywwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQU07QUFDekIsa0JBQWtCLFlBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUNqQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCK0I7QUFDRjs7QUFFdEI7QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDLDBCQUEwQixXQUFLO0FBQy9CLDZCQUE2QixXQUFLO0FBQ2xDO0FBQ0EsMEJBQTBCLFdBQUs7QUFDL0I7O0FBRUE7O0FBRUEseUJBQXlCLElBQUk7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGdDQUFnQztBQUN2RDs7QUFFQSx3QkFBd0IsV0FBSzs7QUFFN0I7O0FBRUEsc0JBQXNCLElBQUk7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLElBQUk7O0FBRXJDO0FBQ0E7O0FBRUEsMkJBQTJCLElBQUk7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEVPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQjtBQUM5RCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7OztBQ3RFc0M7QUFDRDtBQUNGO0FBQ0o7QUFDa0I7QUFDNkI7QUFDZjs7QUFFeEQ7O0FBRVA7QUFDQTtBQUNBOztBQUVBLEVBQUUsY0FBYzs7QUFFaEI7O0FBRUE7QUFDQSxjQUFjLHNCQUFXO0FBQ3pCO0FBQ0E7O0FBRUEsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLFFBQVE7QUFDcEMsMkJBQTJCLFdBQUssRUFBRSxHQUFHO0FBQ3JDLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixjQUFjLFNBQVMsdUJBQXVCLFNBQVM7QUFDdkQsK0JBQStCLGVBQU87QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQSxnQkFBZ0IsR0FBRztBQUNuQiw0QkFBNEIsZUFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixHQUFHLHdCQUF3QixTQUFTO0FBQ2pFO0FBQ0E7QUFDQSxXQUFXLFdBQVcsYUFBYTtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QywwQkFBMEIsZUFBTztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGlCQUFpQjs7QUFFMUMsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQUs7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixXQUFLLEVBQUUsR0FBRztBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixtQkFBbUIsR0FBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyxVQUFVLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUM5S2lFOzs7QUNBVjtBQUN2RCxhQUFhLG1CQUFPLENBQUMsQ0FBZTs7QUFFcEM7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEVkZ2VLZXlzIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5rZXlzID0gW11cbiAgfVxuXG4gIGZpbmRLZXlQb3NpdGlvbiAoZWRnZWtleSwgcCkge1xuICAgIGxldCBsbyA9IDBcbiAgICBsZXQgaGkgPSB0aGlzLmtleXMubGVuZ3RoXG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvICsgaGkpIC8gMilcbiAgICAgIGlmIChlZGdla2V5LmlzTGVzc1RoYW5PdGhlckVkZ2VLZXkodGhpcy5rZXlzW21pZF0pKSBoaSA9IG1pZFxuICAgICAgZWxzZSBsbyA9IG1pZCArIDFcbiAgICB9XG4gICAgcmV0dXJuIGxvXG4gIH1cblxuICBhZGRLZXkgKGVkZ2VrZXksIHApIHtcbiAgICBjb25zdCBsbyA9IHRoaXMuZmluZEtleVBvc2l0aW9uKGVkZ2VrZXkpXG4gICAgdGhpcy5rZXlzLnNwbGljZShsbywgMCwgZWRnZWtleSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgcGkxLCBwaTIgfSBmcm9tICcuL3V0aWxzJ1xuXG5leHBvcnQgY2xhc3MgUG9pbnQge1xuXG4gIGNvbnN0cnVjdG9yIChjb29yZHMsIHBvbHlnb25JRCkge1xuICAgIGlmIChwb2x5Z29uSUQgPT09IG51bGwpIHBvbHlnb25JRCA9IC0xXG4gICAgdGhpcy54ID0gY29vcmRzWzBdXG4gICAgdGhpcy55ID0gY29vcmRzWzFdXG4gICAgdGhpcy5wb2x5Z29uSUQgPSBwb2x5Z29uSURcbiAgICB0aGlzLmVkZ2VzID0gW11cbiAgICB0aGlzLnByZXZQb2ludCA9IG51bGxcbiAgICB0aGlzLm5leHRQb2ludCA9IG51bGxcbiAgfVxuXG4gIGlzUG9pbnRFcXVhbCAob3RoZXJQb2ludCkge1xuICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyUG9pbnQueCAmJiB0aGlzLnkgPT09IG90aGVyUG9pbnQueVxuICB9XG5cbiAgYW5nbGVUb1BvaW50IChvdGhlclBvaW50KSB7XG4gICAgaWYgKHRoaXMuaXNQb2ludEVxdWFsKG90aGVyUG9pbnQpKSByZXR1cm4gMFxuICAgIGNvbnN0IGR4ID0gb3RoZXJQb2ludC54IC0gdGhpcy54XG4gICAgY29uc3QgZHkgPSBvdGhlclBvaW50LnkgLSB0aGlzLnlcbiAgICBpZiAoZHggPT09IDApIGR5IDwgMSA/IHBpMSA6IHBpMlxuICAgIGlmIChkeSA9PT0gMCkgZHggPCAwID8gTWF0aC5QSSA6IDBcbiAgICBpZiAoZHggPCAwKSByZXR1cm4gTWF0aC5QSSArIE1hdGguYXRhbihkeSAvIGR4KVxuICAgIGlmIChkeSA8IDApIHJldHVybiAyICogTWF0aC5QSSArIE1hdGguYXRhbihkeSAvIGR4KVxuICAgIHJldHVybiBNYXRoLmF0YW4oZHkgLyBkeClcbiAgfVxufVxuIiwiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL1BvaW50J1xuXG5leHBvcnQgY29uc3QgcGkxID0gTWF0aC5QSSAqIDMgLyAyXG5leHBvcnQgY29uc3QgcGkyID0gTWF0aC5QSSAvIDJcblxuZXhwb3J0IGNvbnN0IElORiA9IDEwMDAwXG5jb25zdCBDT0xJTl9UT0xFUkFOQ0UgPSAxM1xuY29uc3QgVCA9IE1hdGgucG93KDEwLCBDT0xJTl9UT0xFUkFOQ0UpXG5jb25zdCBUMiA9IE1hdGgucG93KDEwLjAsIENPTElOX1RPTEVSQU5DRSlcblxuZXhwb3J0IGZ1bmN0aW9uIGVkZ2VJbnRlcnNlY3QgKHAxLCBxMSwgZWRnZSkge1xuICBjb25zdCBwMiA9IGVkZ2UucDFcbiAgY29uc3QgcTIgPSBlZGdlLnAyXG4gIGNvbnN0IG8xID0gY2N3KHAxLCBxMSwgcDIpXG4gIGNvbnN0IG8yID0gY2N3KHAxLCBxMSwgcTIpXG4gIGNvbnN0IG8zID0gY2N3KHAyLCBxMiwgcDEpXG4gIGNvbnN0IG80ID0gY2N3KHAyLCBxMiwgcTEpXG4gIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZVxuICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZVxuICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZVxuICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZVxuICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNjdyAoYSwgYiwgYykge1xuICBjb25zdCBhcmVhID0gTWF0aC5yb3VuZCgoKGIueCAtIGEueCkgKiAoYy55IC0gYS55KSAtIChiLnkgLSBhLnkpICogKGMueCAtIGEueCkpICogVCkgLyBUMlxuICBpZiAoYXJlYSA+IDApIHJldHVybiAxXG4gIGlmIChhcmVhIDwgMCkgcmV0dXJuIC0xXG4gIHJldHVybiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblNlZ21lbnQgKHAsIHEsIHIpIHtcbiAgaWYgKHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSkge1xuICAgIGlmIChxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSkpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZTIgKHAxLCBwMiwgcDMpIHtcbiAgY29uc3QgYSA9IE1hdGgucG93KChwMy54IC0gcDIueCksIDIpICsgTWF0aC5wb3coKHAzLnkgLSBwMi55KSwgMilcbiAgY29uc3QgYiA9IE1hdGgucG93KChwMy54IC0gcDEueCksIDIpICsgTWF0aC5wb3coKHAzLnkgLSBwMS55KSwgMilcbiAgY29uc3QgYyA9IE1hdGgucG93KChwMi54IC0gcDEueCksIDIpICsgTWF0aC5wb3coKHAyLnkgLSBwMS55KSwgMilcbiAgcmV0dXJuIE1hdGguYWNvcygoYSArIGMgLSBiKSAvICgyICogTWF0aC5zcXJ0KGEpICogTWF0aC5zcXJ0KGMpKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50RWRnZURpc3RhbmNlIChwMSwgcDIsIGVkZ2UpIHtcbiAgY29uc3QgaXAgPSBpbnRlcnNlY3RQb2ludChwMSwgcDIsIGVkZ2UpXG4gIHJldHVybiBpcCAhPT0gbnVsbCA/IGNhbGNFZGdlRGlzdGFuY2UocDEsIGlwKSA6IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdFBvaW50IChwMSwgcDIsIGVkZ2UpIHtcbiAgaWYgKGVkZ2UuY29udGFpbnNQb2ludChwMSkpIHJldHVybiBwMVxuICBpZiAoZWRnZS5jb250YWluc1BvaW50KHAyKSkgcmV0dXJuIHAyXG4gIGlmIChlZGdlLnAxLnggPT09IGVkZ2UucDIueCkge1xuICAgIGlmIChwMS54ID09PSBwMi54KSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IHBzbG9wZSA9IChwMS55IC0gcDIueSkgLyAocDEueCAtIHAyLngpXG4gICAgY29uc3QgaW50ZXJzZWN0WCA9IGVkZ2UucDEueFxuICAgIGNvbnN0IGludGVyc2VjdFkgPSBwc2xvcGUgKiAoaW50ZXJzZWN0WCAtIHAxLngpICsgcDEueVxuICAgIHJldHVybiBuZXcgUG9pbnQoW2ludGVyc2VjdFgsIGludGVyc2VjdFldLCBudWxsKVxuICB9XG4gIGlmIChwMS54ID09PSBwMi54KSB7XG4gICAgY29uc3QgZXNsb3BlID0gKGVkZ2UucDEueSAtIGVkZ2UucDIueSkgLyAoZWRnZS5wMS54IC0gZWRnZS5wMi54KVxuICAgIGNvbnN0IGludGVyc2VjdFggPSBwMS54XG4gICAgY29uc3QgaW50ZXJzZWN0WSA9IGVzbG9wZSAqIChpbnRlcnNlY3RYIC0gZWRnZS5wMS54KSArIGVkZ2UucDEueVxuICAgIHJldHVybiBuZXcgUG9pbnQoW2ludGVyc2VjdFgsIGludGVyc2VjdFldLCBudWxsKVxuICB9XG5cbiAgY29uc3QgcHNsb3BlID0gKHAxLnkgLSBwMi55KSAvIChwMS54IC0gcDIueClcbiAgY29uc3QgZXNsb3BlID0gKGVkZ2UucDEueSAtIGVkZ2UucDIueSkgLyAoZWRnZS5wMS54IC0gZWRnZS5wMi54KVxuXG4gIGlmIChwc2xvcGUgPT09IGVzbG9wZSkgcmV0dXJuIG51bGxcbiAgY29uc3QgaW50ZXJzZWN0WCA9IChlc2xvcGUgKiBlZGdlLnAxLnggLSBwc2xvcGUgKiBwMS54ICsgcDEueSAtIGVkZ2UucDEueSkgLyAoZXNsb3BlIC0gcHNsb3BlKVxuICBjb25zdCBpbnRlcnNlY3RZID0gZXNsb3BlICogKGludGVyc2VjdFggLSBlZGdlLnAxLngpICsgZWRnZS5wMS55XG4gIHJldHVybiBuZXcgUG9pbnQoW2ludGVyc2VjdFgsIGludGVyc2VjdFldLCBudWxsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY0VkZ2VEaXN0YW5jZSAocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDIueCAtIHAxLngsIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKVxufVxuIiwiaW1wb3J0IHsgZWRnZUludGVyc2VjdCwgcG9pbnRFZGdlRGlzdGFuY2UsIGFuZ2xlMiB9IGZyb20gJy4vdXRpbHMnXG5cbmV4cG9ydCBjbGFzcyBFZGdlS2V5IHtcblxuICBjb25zdHJ1Y3RvciAocDEsIHAyLCBlZGdlKSB7XG4gICAgdGhpcy5wMSA9IHAxXG4gICAgdGhpcy5wMiA9IHAyXG4gICAgdGhpcy5lZGdlID0gZWRnZVxuICB9XG5cbiAgaXNMZXNzVGhhbk90aGVyRWRnZUtleSAob3RoZXJFZGdlS2V5KSB7XG4gICAgaWYgKHRoaXMubWF0Y2hlc090aGVyS2V5KG90aGVyRWRnZUtleSkpIHJldHVybiBmYWxzZVxuICAgIGlmICghZWRnZUludGVyc2VjdCh0aGlzLnAxLCB0aGlzLnAyLCBvdGhlckVkZ2VLZXkuZWRnZSkpIHJldHVybiB0cnVlXG4gICAgY29uc3Qgc2VsZkRpc3RhbmNlID0gcG9pbnRFZGdlRGlzdGFuY2UodGhpcy5wMSwgdGhpcy5wMiwgdGhpcy5lZGdlKVxuICAgIGNvbnN0IG90aGVyRGlzdGFuY2UgPSBwb2ludEVkZ2VEaXN0YW5jZSh0aGlzLnAxLCB0aGlzLnAyLCBvdGhlckVkZ2VLZXkuZWRnZSlcbiAgICBpZiAoc2VsZkRpc3RhbmNlID4gb3RoZXJEaXN0YW5jZSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHNlbGZEaXN0YW5jZSA8IG90aGVyRGlzdGFuY2UpIHJldHVybiB0cnVlXG4gICAgaWYgKHNlbGZEaXN0YW5jZSA9PT0gb3RoZXJEaXN0YW5jZSkge1xuICAgICAgbGV0IHNhbWVQb2ludCA9IG51bGxcbiAgICAgIGlmIChvdGhlckVkZ2VLZXkuZWRnZS5jb250YWluc1BvaW50KHRoaXMuZWRnZS5wMSkpIHNhbWVQb2ludCA9IHRoaXMuZWRnZS5wMVxuICAgICAgLy8gZWxzZSBpZiAob3RoZXJFZGdlS2V5LmVkZ2UuY29udGFpbnNQb2ludCh0aGlzLmVkZ2UucDIpKSBzYW1lUG9pbnQgPSB0aGlzLmVkZ2UucDJcbiAgICAgIGVsc2Ugc2FtZVBvaW50ID0gdGhpcy5lZGdlLnAyXG4gICAgICBjb25zdCBhc2xmID0gYW5nbGUyKHRoaXMucDEsIHRoaXMucDIsIHRoaXMuZWRnZS5nZXRPdGhlclBvaW50SW5FZGdlKHNhbWVQb2ludCkpXG4gICAgICBjb25zdCBhb3QgPSBhbmdsZTIodGhpcy5wMSwgdGhpcy5wMiwgb3RoZXJFZGdlS2V5LmVkZ2UuZ2V0T3RoZXJQb2ludEluRWRnZShzYW1lUG9pbnQpKVxuICAgICAgaWYgKGFzbGYgPCBhb3QpIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBtYXRjaGVzT3RoZXJLZXkgKG90aGVyS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZS5hcmVFZGdlc0VxdWFsKG90aGVyS2V5LmVkZ2UpXG4gIH1cblxufVxuIiwiZXhwb3J0IGNsYXNzIEVkZ2Uge1xuICBjb25zdHJ1Y3RvciAocDEsIHAyKSB7XG4gICAgdGhpcy5wMSA9IHAxXG4gICAgdGhpcy5wMiA9IHAyXG5cbiAgICBwMS5lZGdlcy5wdXNoKHRoaXMpXG4gICAgcDIuZWRnZXMucHVzaCh0aGlzKVxuICB9XG5cbiAgZ2V0T3RoZXJQb2ludEluRWRnZSAocG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5wMS5pc1BvaW50RXF1YWwocG9pbnQpID8gdGhpcy5wMiA6IHRoaXMucDFcbiAgfVxuXG4gIGFyZUVkZ2VzRXF1YWwgKG90aGVyRWRnZSkge1xuICAgIGlmICh0aGlzLnAxLmlzUG9pbnRFcXVhbChvdGhlckVkZ2UucDEpICYmIHRoaXMucDIuaXNQb2ludEVxdWFsKG90aGVyRWRnZS5wMikpIHJldHVybiB0cnVlXG4gICAgaWYgKHRoaXMucDEuaXNQb2ludEVxdWFsKG90aGVyRWRnZS5wMikgJiYgdGhpcy5wMi5pc1BvaW50RXF1YWwob3RoZXJFZGdlLnAxKSkgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnRhaW5zUG9pbnQgKHBvaW50KSB7XG4gICAgaWYgKHRoaXMucDEuaXNQb2ludEVxdWFsKHBvaW50KSB8fCB0aGlzLnAyLmlzUG9pbnRFcXVhbChwb2ludCkpIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9Qb2ludCdcbmltcG9ydCB7IEVkZ2UgfSBmcm9tICcuL0VkZ2UnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFN0cnVjdHVyZSAoZ2VvanNvbiwgZWRnZXMsIHBvaW50cywgcG9seWdvbnMpIHtcbiAgY29uc3QgZ2VvbSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb25cblxuICBsZXQgY29vcmRzID0gZ2VvbS5jb29yZGluYXRlc1xuXG4gIC8vIHN0YW5kYXJkaXNlIHRoZSBpbnB1dFxuICBpZiAoZ2VvbS50eXBlID09PSAnUG9seWdvbicpIGNvb3JkcyA9IFtjb29yZHNdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb250b3VyID0gW11cbiAgICBwb2x5Z29ucy5wdXNoKGNvbnRvdXIpXG5cbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgY29vcmRzW2ldLmxlbmd0aDsgaWkrKykge1xuICAgICAgbGV0IHByZXZQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzBdLCBpKVxuICAgICAgbGV0IGN1cnJlbnRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzFdLCBpKVxuICAgICAgcHJldlBvaW50Lm5leHRQb2ludCA9IGN1cnJlbnRQb2ludFxuICAgICAgbGV0IG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzJdLCBpKVxuICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50KVxuXG4gICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG5cbiAgICAgIGxldCBwcmV2RWRnZSA9IG5ldyBFZGdlKHByZXZQb2ludCwgY3VycmVudFBvaW50KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBlZGdlcy5wdXNoKHByZXZFZGdlKVxuICAgICAgY29udG91ci5wdXNoKHByZXZFZGdlKVxuXG4gICAgICAvLyBTYXZlIG1lIGZvciBsYXRlclxuICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHByZXZQb2ludFxuXG4gICAgICBwcmV2UG9pbnQgPSBjdXJyZW50UG9pbnRcbiAgICAgIGN1cnJlbnRQb2ludCA9IG5leHRQb2ludFxuXG4gICAgICBmb3IgKGxldCBpaWkgPSAyOyBpaWkgPCBjb29yZHNbaV1baWldLmxlbmd0aCAtIDI7IGlpaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcblxuICAgICAgICBuZXh0UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldW2lpXVtpaWkgKyAxXSwgaSlcblxuICAgICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQpXG5cbiAgICAgICAgY29uc3QgZSA9IG5ldyBFZGdlKHByZXZQb2ludCwgY3VycmVudFBvaW50KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgZWRnZXMucHVzaChlKVxuICAgICAgICBjb250b3VyLnB1c2goZSlcblxuICAgICAgICBwcmV2UG9pbnQgPSBjdXJyZW50UG9pbnRcbiAgICAgICAgY3VycmVudFBvaW50ID0gbmV4dFBvaW50XG4gICAgICAgIHByZXZFZGdlID0gZVxuICAgICAgfVxuXG4gICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBmaXJzdFBvaW50KVxuXG4gICAgICBjb25zdCBzZWNvbmRMYXN0RWRnZSA9IG5ldyBFZGdlKHByZXZFZGdlLnAyLCBjdXJyZW50UG9pbnQpXG5cbiAgICAgIGVkZ2VzLnB1c2goc2Vjb25kTGFzdEVkZ2UpXG4gICAgICBjb250b3VyLnB1c2goc2Vjb25kTGFzdEVkZ2UpXG5cbiAgICAgIGNvbnN0IGxhc3RFZGdlID0gbmV3IEVkZ2UoY3VycmVudFBvaW50LCBmaXJzdFBvaW50KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBsaW5rUG9pbnRzKGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludCwgZmlyc3RQb2ludC5uZXh0UG9pbnQpXG5cbiAgICAgIGVkZ2VzLnB1c2gobGFzdEVkZ2UpXG4gICAgICBjb250b3VyLnB1c2gobGFzdEVkZ2UpXG5cbiAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcbiAgICAgIHBvaW50cy5wdXNoKG5leHRQb2ludClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGlua1BvaW50cyAocHJldlBvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCkge1xuICBjdXJyZW50UG9pbnQucHJldlBvaW50ID0gcHJldlBvaW50XG4gIGN1cnJlbnRQb2ludC5uZXh0UG9pbnQgPSBuZXh0UG9pbnRcbn1cbiIsIlxuZXhwb3J0IGZ1bmN0aW9uIF9yZW5kZXJTb3J0ZWRQb2ludHMgKHBvaW50LCBzb3J0ZWRQb2ludHMpIHtcbiAgY29uc3QgbWFwID0gd2luZG93Lm1hcFxuICB2YXIgc29ydGVkUG9pbnRzTGcgPSBudWxsXG5cbiAgTC5OdW1iZXJlZERpdkljb24gPSBjcmVhdGVOdW1iZXJEaXYoKVxuXG4gIHNldEN1cnJlbnRQb2ludChwb2ludClcblxuICBpZiAoc29ydGVkUG9pbnRzTGcgPT09IG51bGwpIHNvcnRlZFBvaW50c0xnID0gTC5sYXllckdyb3VwKFtdKS5hZGRUbyhtYXApXG4gIGVsc2Ugc29ydGVkUG9pbnRzTGcuY2xlYXJMYXllcnMoKVxuICBzb3J0ZWRQb2ludHMuZm9yRWFjaCgocCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gTC5tYXJrZXIoW3AueSwgcC54XSwge1xuICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICBpY29uOiBuZXcgTC5OdW1iZXJlZERpdkljb24oeyBudW1iZXI6IGluZGV4LnRvU3RyaW5nKCkgfSlcbiAgICB9KS5hZGRUbyhzb3J0ZWRQb2ludHNMZylcbiAgfSlcblxuICAvLyBkZWJ1Z2dlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3JlbmRlck9wZW5FZGdlcyAocG9pbnQsIGVkZ2VzKSB7XG4gIGNvbnN0IG1hcCA9IHdpbmRvdy5tYXBcbiAgY29uc3QgY3VycmVudFBvaW50ID0gTC5jaXJjbGVNYXJrZXIoW3BvaW50LnksIHBvaW50LnhdLCB7XG4gICAgcmFkaXVzOiAyMCxcbiAgICBjb2xvcjogJ2dyZWVuJ1xuICB9KS5hZGRUbyhtYXApXG4gIHZhciBvcGVuRWRnZXMgPSBMLmxheWVyR3JvdXAoW10pLmFkZFRvKG1hcClcblxuICBlZGdlcy5mb3JFYWNoKChlLCBpbmRleCkgPT4ge1xuICAgIEwucG9seWxpbmUoW1tlLmVkZ2UucDEueSwgZS5lZGdlLnAxLnhdLCBbZS5lZGdlLnAyLnksIGUuZWRnZS5wMi54XV0sIHtcbiAgICAgIGNvbG9yOiAncmVkJ1xuICAgIH0pLmFkZFRvKG9wZW5FZGdlcylcbiAgfSlcblxuICAvLyBkZWJ1Z2dlclxuICBvcGVuRWRnZXMuY2xlYXJMYXllcnMoKVxuICBtYXAucmVtb3ZlTGF5ZXIoY3VycmVudFBvaW50KVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UG9pbnQgKHBvaW50KSB7XG4gIGNvbnN0IG1hcCA9IHdpbmRvdy5tYXBcbiAgbGV0IGN1cnJlbnRQb2ludCA9IG51bGxcblxuICBpZiAoY3VycmVudFBvaW50ICE9PSBudWxsKSBtYXAucmVtb3ZlTGF5ZXIoY3VycmVudFBvaW50KVxuXG4gIGN1cnJlbnRQb2ludCA9IEwuY2lyY2xlTWFya2VyKFtwb2ludC55LCBwb2ludC54XSwge1xuICAgIHJhZGl1czogMjAsXG4gICAgY29sb3I6ICdncmVlbidcbiAgfSkuYWRkVG8obWFwKVxuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU51bWJlckRpdiAoKSB7XG4gIHJldHVybiBMLkljb24uZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBudW1iZXI6ICcnLFxuICAgICAgaWNvblNpemU6IG5ldyBMLlBvaW50KDI1LCAyNSksXG4gICAgICBjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJ1xuICAgIH0sXG4gICAgY3JlYXRlSWNvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICB2YXIgbnVtZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIG51bWRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ251bWJlcicpXG4gICAgICBudW1kaXYuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zWydudW1iZXInXSB8fCAnJ1xuICAgICAgZGl2LmFwcGVuZENoaWxkKG51bWRpdilcbiAgICAgIHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpXG4gICAgICByZXR1cm4gZGl2XG4gICAgfVxuICB9KVxufVxuXG4iLCJpbXBvcnQgY3JlYXRlR3JhcGggZnJvbSAnbmdyYXBoLmdyYXBoJ1xuaW1wb3J0IHsgRWRnZUtleXMgfSBmcm9tICcuL0VkZ2VLZXlzJ1xuaW1wb3J0IHsgRWRnZUtleSB9IGZyb20gJy4vRWRnZUtleSdcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9Qb2ludCdcbmltcG9ydCB7IHNldHVwU3RydWN0dXJlIH0gZnJvbSAnLi9zZXR1cFN0cnVjdHVyZSdcbmltcG9ydCB7IElORiwgZWRnZUludGVyc2VjdCwgb25TZWdtZW50LCBjY3csIGNhbGNFZGdlRGlzdGFuY2UgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgX3JlbmRlclNvcnRlZFBvaW50cywgX3JlbmRlck9wZW5FZGdlcyB9IGZyb20gJy4vZGVidWcnIC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR3JhcGhGcm9tR2VvSnNvbiAoZ2VvanNvbikge1xuXG4gIGNvbnN0IHBvaW50cyA9IFtdXG4gIGNvbnN0IGVkZ2VzID0gW11cbiAgY29uc3QgcG9seWdvbnMgPSBbXVxuXG4gIHNldHVwU3RydWN0dXJlKGdlb2pzb24sIGVkZ2VzLCBwb2ludHMsIHBvbHlnb25zKVxuXG4gIHJldHVybiBwcm9jZXNzR3JhcGgoKVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NHcmFwaCAoKSB7XG4gICAgY29uc3QgZyA9IGNyZWF0ZUdyYXBoKClcbiAgICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoXG4gICAgY29uc3QgY2xvbmVkUG9pbnRzID0gY2xvbmVQb2ludHMoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHNMZW47IGkrKykge1xuICAgICAgY29uc3QgcCA9IHBvaW50c1tpXVxuICAgICAgY29uc3QgcHJldlBvaW50ID0gcC5wcmV2UG9pbnRcbiAgICAgIGNvbnN0IG5leHRQb2ludCA9IHAubmV4dFBvaW50XG5cbiAgICAgIHNvcnRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuICAgICAgLy8gX3JlbmRlclNvcnRlZFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG5cbiAgICAgIGNvbnN0IG9wZW5FZGdlcyA9IG5ldyBFZGdlS2V5cygpXG4gICAgICBjb25zdCBwb2ludEluZiA9IG5ldyBQb2ludChbSU5GLCBwLnldLCBudWxsKVxuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuICAgICAgICBjb25zdCBlID0gZWRnZXNbaWldXG4gICAgICAgIGlmIChlLmNvbnRhaW5zUG9pbnQocCkpIGNvbnRpbnVlXG4gICAgICAgIGlmIChlZGdlSW50ZXJzZWN0KHAsIHBvaW50SW5mLCBlKSkge1xuICAgICAgICAgIGlmIChvblNlZ21lbnQocCwgZS5wMSwgcG9pbnRJbmYpIHx8IG9uU2VnbWVudChwLCBlLnAyLCBwb2ludEluZikpIGNvbnRpbnVlXG4gICAgICAgICAgb3BlbkVkZ2VzLmFkZEtleShuZXcgRWRnZUtleShwLCBwb2ludEluZiwgZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIF9yZW5kZXJPcGVuRWRnZXMocCwgb3BlbkVkZ2VzLmtleXMpXG5cbiAgICAgIGNvbnN0IHZpc2libGUgPSBbXVxuICAgICAgbGV0IHByZXYgPSBudWxsXG4gICAgICBsZXQgcHJldlZpc2libGUgPSBudWxsXG5cbiAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBwb2ludHNMZW47IGlpKyspIHtcbiAgICAgICAgY29uc3QgcDIgPSBjbG9uZWRQb2ludHNbaWldXG4gICAgICAgIGlmIChwMi5pc1BvaW50RXF1YWwocCkpIGNvbnRpbnVlXG4gICAgICAgIGlmIChwLmFuZ2xlVG9Qb2ludChwMikgPiBNYXRoLnBpKSBicmVha1xuXG4gICAgICAgIGlmIChvcGVuRWRnZXMua2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICAgICAgY29uc3QgZSA9IHAyLmVkZ2VzW2lpaV1cbiAgICAgICAgICAgIGlmIChjY3cocCwgcDIsIGUuZ2V0T3RoZXJQb2ludEluRWRnZShwMikpID09PSAtMSkge1xuICAgICAgICAgICAgICBjb25zdCBrID0gbmV3IEVkZ2VLZXkocCwgcDIsIGUpXG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3BlbkVkZ2VzLmZpbmRLZXlQb3NpdGlvbihrKSAtIDFcbiAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBvcGVuRWRnZXMua2V5c1tpbmRleF0ubWF0Y2hlc090aGVyS2V5KGspKSB7XG4gICAgICAgICAgICAgICAgb3BlbkVkZ2VzLmtleXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICAgIGlmIChwcmV2ID09PSBudWxsIHx8IGNjdyhwLCBwcmV2LCBwMikgIT09IDAgfHwgIW9uU2VnbWVudChwLCBwcmV2LCBwMikpIHtcbiAgICAgICAgICBpZiAob3BlbkVkZ2VzLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAgICAgfSBlbHNlIGlmICghZWRnZUludGVyc2VjdChwLCBwMiwgb3BlbkVkZ2VzLmtleXNbMF0uZWRnZSkpIHtcbiAgICAgICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXByZXZWaXNpYmxlKSB7XG4gICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgb3BlbkVkZ2VzLmtleXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICAgICAgY29uc3QgZSA9IG9wZW5FZGdlcy5rZXlzW2lpaV1cbiAgICAgICAgICAgIGlmICghZS5lZGdlLmNvbnRhaW5zUG9pbnQocHJldikgJiYgZWRnZUludGVyc2VjdChwcmV2LCBwMiwgZS5lZGdlKSkge1xuICAgICAgICAgICAgICBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNWaXNpYmxlICYmIGVkZ2VJblBvbHlnb24ocHJldiwgcDIpKSBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNJbkFkamFjZW50UG9pbnRzID0gcDIuaXNQb2ludEVxdWFsKHByZXZQb2ludCkgfHwgcDIuaXNQb2ludEVxdWFsKG5leHRQb2ludClcbiAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiAhaXNJbkFkamFjZW50UG9pbnRzKSBpc1Zpc2libGUgPSAhZWRnZUluUG9seWdvbihwLCBwMilcblxuICAgICAgICBpZiAoaXNWaXNpYmxlKSB2aXNpYmxlLnB1c2gocDIpXG5cbiAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4gICAgICAgICAgaWYgKCFlLmNvbnRhaW5zUG9pbnQocCkgJiYgY2N3KHAsIHAyLCBlLmdldE90aGVyUG9pbnRJbkVkZ2UocDIpKSA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgayA9IG5ldyBFZGdlS2V5KHAsIHAyLCBlKVxuICAgICAgICAgICAgb3BlbkVkZ2VzLmFkZEtleShrKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByZXYgPSBwMlxuICAgICAgICBwcmV2VmlzaWJsZSA9IGlzVmlzaWJsZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlSWQgPSBjcmVhdGVOb2RlSWQocClcbiAgICAgIGcuYWRkTm9kZShub2RlSWQsIHsgeDogcC54LCB5OiBwLnkgfSlcblxuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZpc2libGUubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIGNvbnN0IG90aGVyTm9kZUlkID0gY3JlYXRlTm9kZUlkKHZpc2libGVbaWldKVxuICAgICAgICBnLmFkZE5vZGUob3RoZXJOb2RlSWQsIHsgeDogdmlzaWJsZVtpaV0ueCwgeTogdmlzaWJsZVtpaV0ueSB9KVxuICAgICAgICBnLmFkZExpbmsobm9kZUlkLCBvdGhlck5vZGVJZClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVJZCAocCkge1xuICAgIHJldHVybiBwLnggKyAnLCcgKyBwLnlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lUG9pbnRzICgpIHtcbiAgICByZXR1cm4gcG9pbnRzLnNsaWNlKDApXG4gIH1cblxuICBmdW5jdGlvbiBzb3J0UG9pbnRzIChwb2ludCwgY2xvbmVkUG9pbnRzKSB7XG4gICAgY2xvbmVkUG9pbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFuZ2xlMSA9IHBvaW50LmFuZ2xlVG9Qb2ludChhKVxuICAgICAgY29uc3QgYW5nbGUyID0gcG9pbnQuYW5nbGVUb1BvaW50KGIpXG4gICAgICBpZiAoYW5nbGUxIDwgYW5nbGUyKSByZXR1cm4gLTFcbiAgICAgIGlmIChhbmdsZTEgPiBhbmdsZTIpIHJldHVybiAxXG4gICAgICBjb25zdCBkaXN0MSA9IGNhbGNFZGdlRGlzdGFuY2UocG9pbnQsIGEpXG4gICAgICBjb25zdCBkaXN0MiA9IGNhbGNFZGdlRGlzdGFuY2UocG9pbnQsIGIpXG4gICAgICBpZiAoZGlzdDEgPCBkaXN0MikgcmV0dXJuIC0xXG4gICAgICBpZiAoZGlzdDEgPiBkaXN0MikgcmV0dXJuIDFcbiAgICAgIHJldHVybiAwXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVkZ2VJblBvbHlnb24gKHAxLCBwMikge1xuICAgIGlmIChwMS5wb2x5Z29uSUQgIT09IHAyLnBvbHlnb25JRCkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHAxLnBvbHlnb25JRCA9PT0gLTEgfHwgcDIucG9seWdvbklEID09PSAtMSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgbWlkUG9pbnQgPSBuZXcgUG9pbnQoWyhwMS54ICsgcDIueCkgLyAyLCAocDEueSArIHAyLnkpIC8gMl0sIG51bGwpXG4gICAgcmV0dXJuIHBvbHlnb25Dcm9zc2luZyhtaWRQb2ludCwgcG9seWdvbnNbcDEucG9seWdvbklEXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb25Dcm9zc2luZyAocDEsIHBvbHlFZGdlcykge1xuICAgIGNvbnN0IHAyID0gbmV3IFBvaW50KFtJTkYsIHAxLnldLCBudWxsKVxuICAgIGxldCBpbnRlcnNlY3RDb3VudCA9IDBcbiAgICBsZXQgY29GbGFnID0gZmFsc2VcbiAgICBsZXQgY29EaXIgPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZSA9IHBvbHlFZGdlc1tpXVxuICAgICAgaWYgKHAxLnkgPCBlLnAxLnkgJiYgcDEueSA8IGUucDIueSkgY29udGludWVcbiAgICAgIGlmIChwMS55ID4gZS5wMS55ICYmIHAxLnkgPiBlLnAyLnkpIGNvbnRpbnVlXG4gICAgICBjb25zdCBjbzAgPSAoY2N3KHAxLCBlLnAxLCBwMikgPT09IDApICYmIChlLnAxLnggPiBwMS54KVxuICAgICAgY29uc3QgY28xID0gKGNjdyhwMSwgZS5wMiwgcDIpID09PSAwKSAmJiAoZS5wMi54ID4gcDEueClcbiAgICAgIGNvbnN0IGNvUG9pbnQgPSBjbzAgPyBlLnAxIDogZS5wMlxuICAgICAgaWYgKGNvMCB8fCBjbzEpIHtcbiAgICAgICAgY29EaXIgPSBlLmdldE90aGVyUG9pbnRJbkVkZ2UoY29Qb2ludCkueSA+IHAxLnkgPyBjb0RpcisrIDogY29EaXItLVxuICAgICAgICBpZiAoY29GbGFnKSB7XG4gICAgICAgICAgaWYgKGNvRGlyID09PSAwKSBpbnRlcnNlY3RDb3VudCsrXG4gICAgICAgICAgY29GbGFnID0gZmFsc2VcbiAgICAgICAgICBjb0RpciA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb0ZsYWcgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWRnZUludGVyc2VjdChwMSwgcDIsIGUpKSB7XG4gICAgICAgIGludGVyc2VjdENvdW50KytcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGludGVyc2VjdENvdW50ICUgMiA9PT0gMCkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG59XG4iLCJleHBvcnQgeyBjcmVhdGVHcmFwaEZyb21HZW9Kc29uIH0gZnJvbSAnLi9jcmVhdGVHcmFwaEZyb21HZW9Kc29uJ1xuIiwiaW1wb3J0IHsgY3JlYXRlR3JhcGhGcm9tR2VvSnNvbiB9IGZyb20gJy4uLy4uL3NyYy9tYWluJ1xudmFyIHRvanNvbiA9IHJlcXVpcmUoJ25ncmFwaC50b2pzb24nKVxuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZSkge1xuICBjb25zdCBvdXRHcmFwaCA9IGNyZWF0ZUdyYXBoRnJvbUdlb0pzb24oZS5kYXRhKVxuICBjb25zdCBqc29uQ29udGVudCA9IHRvanNvbihvdXRHcmFwaClcblxuICBzZWxmLnBvc3RNZXNzYWdlKGpzb25Db250ZW50KVxufSwgZmFsc2UpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")}]);