{"version":3,"file":"vg.js","sources":["../node_modules/@turf/helpers/main.es.js","../node_modules/@turf/meta/main.es.js","../src/Edge.js","../src/EdgeKeys.js","../src/Point.js","../src/utils.js","../src/EdgeKey.js","../src/debug.js","../src/Graph.js"],"sourcesContent":["/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","export class Edge {\r\n  constructor (p1, p2, polygonID) {\r\n    this.p1 = p1\r\n    this.p2 = p2\r\n  }\r\n\r\n  getOtherPointInEdge (point) {\r\n    return this.p1.isPointEqual(point) ? this.p2 : this.p1\r\n  }\r\n\r\n  areEdgesEquals (otherEdge) {\r\n    if (this.p1 === otherEdge.p1 && this.p2 === otherEdge.p2) return true\r\n    if (this.p12 === otherEdge.p1 && this.p1 === otherEdge.p2) return true\r\n    return false\r\n  }\r\n\r\n  containsPoint (point) {\r\n    if (this.p1.isPointEqual(point) || this.p2.isPointEqual(point)) return true\r\n    return false\r\n  }\r\n}\r\n","export class EdgeKeys {\r\n\r\n  constructor () {\r\n    this.keys = []\r\n  }\r\n\r\n  findKeyPosition (edgekey) {\r\n    let lo = 0\r\n    let hi = this.keys.length\r\n    while (lo < hi) {\r\n      const mid = Math.floor((lo + hi) / 2)\r\n      if (edgekey.isLessThanOtherEdgeKey(this.keys[mid])) hi = mid\r\n      else lo = mid + 1\r\n    }\r\n    return lo\r\n  }\r\n\r\n  addKey (edgekey) {\r\n    const lo = this.findKeyPosition(edgekey)\r\n    this.keys.splice(lo, 0, edgekey)\r\n  }\r\n\r\n}\r\n","import { edgeDistance, pi1, pi2 } from './utils'\r\n\r\nexport class Point {\r\n\r\n  constructor (x, y, polygonID) {\r\n    if (polygonID === undefined) polygonID = -1\r\n    this.x = x\r\n    this.y = y\r\n    this.polygonID = polygonID\r\n  }\r\n\r\n  isPointEqual (otherPoint) {\r\n    return this.x && otherPoint.x && this.y === otherPoint.y\r\n  }\r\n\r\n  angleToPoint (otherPoint) {\r\n    if (this.x === otherPoint.x && this.y === otherPoint.y) return 0\r\n    const dx = otherPoint.x - this.x\r\n    const dy = otherPoint.y - this.y\r\n    if (dx === 0) dy < 1 ? pi1 : pi2\r\n    if (dy === 0) dx < 0 ? Math.PI : 0\r\n    if (dx < 0) return Math.PI + Math.atan(dy / dx)\r\n    if (dy < 0) return 2 * Math.PI + Math.atan(dy / dx)\r\n    return Math.atan(dy / dx)\r\n  }\r\n\r\n  edgeDistance (otherPoint) {\r\n    return edgeDistance(this, otherPoint)\r\n  }\r\n}\r\n","import { Point } from './Point'\r\n\r\nexport const pi1 = Math.PI * 3 / 2\r\nexport const pi2 = Math.PI / 2\r\n\r\nexport const INF = 10000\r\nconst COLIN_TOLERANCE = 13\r\nconst T = Math.pow(10, COLIN_TOLERANCE)\r\nconst T2 = Math.pow(10.0, COLIN_TOLERANCE)\r\n\r\nexport function edgeIntersect (p1, q1, edge) {\r\n  const p2 = edge.p1\r\n  const q2 = edge.p2\r\n  const o1 = ccw(p1, q1, p2)\r\n  const o2 = ccw(p1, q1, q2)\r\n  const o3 = ccw(p2, q2, p1)\r\n  const o4 = ccw(p2, q2, q1)\r\n  if (o1 !== o2 && o3 !== o4) return true\r\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true\r\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true\r\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true\r\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true\r\n  return false\r\n}\r\n\r\nexport function ccw (a, b, c) {\r\n  const area = parseInt(((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) * T) / T2\r\n  if (area > 0) return 1\r\n  if (area < 0) return -1\r\n  return 0\r\n}\r\n\r\nexport function onSegment (p, q, r) {\r\n  if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x)) {\r\n    if (q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) return true\r\n  }\r\n  return false\r\n}\r\n\r\nexport function angle2 (p1, p2, p3) {\r\n  const a = Math.pow((p3.x - p2.x), 2) + Math.pow((p3.y - p2.y), 2)\r\n  const b = Math.pow((p3.x - p1.x), 2) + Math.pow((p3.y - p1.y), 2)\r\n  const c = Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2)\r\n  return Math.acos((a + c - b) / (2 * Math.sqrt(a) * Math.sqrt(c)))\r\n}\r\n\r\nexport function pointEdgeDistance (p1, p2, edge) {\r\n  const ip = intersectPoint(p1, p2, edge)\r\n  return ip !== null ? edgeDistance(p1, ip) : 0\r\n}\r\n\r\nfunction intersectPoint (p1, p2, edge) {\r\n  if (edge.containsPoint(p1)) return p1\r\n  if (edge.containsPoint(p2)) return p2\r\n  if (edge.p1.x === edge.p2.px) {\r\n    if (p1.x === p2.x) return null\r\n    const pslope = (p1.y - p2.y) / (p1.x - p2.x)\r\n    const intersectX = edge.p1.x\r\n    const intersectY = pslope * (intersectX - p1.x) + p1.y\r\n    return new Point(intersectX, intersectY)\r\n  }\r\n  if (p1.x === p2.x) {\r\n    const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\r\n    const intersectX = edge.p1.x\r\n    const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\r\n    return new Point(intersectX, intersectY)\r\n  }\r\n  const pslope = (p1.y - p2.y) / (p1.x - p2.x)\r\n  const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\r\n  if (pslope === eslope) return null\r\n  const intersectX = (eslope * edge.p1.x - pslope * p1.x + p1.y - edge.p1.y) / (eslope - pslope)\r\n  const intersectY = eslope * (intersectY - edge.p1.x) + edge.p1.y\r\n  return new Point(intersectX, intersectY)\r\n}\r\n\r\nexport function edgeDistance (p1, p2) {\r\n  return Math.sqrt(((p2.x - p1.x) * 2) + (p2.y - p1.y) * 2)\r\n}\r\n","import { edgeIntersect, pointEdgeDistance, angle2 } from './utils'\r\n\r\nexport class EdgeKey {\r\n\r\n  constructor (p1, p2, edge) {\r\n    this.p1 = p1\r\n    this.p2 = p2\r\n    this.edge = edge\r\n  }\r\n\r\n  isLessThanOtherEdgeKey (otherEdgeKey) {\r\n    if (this.edge === otherEdgeKey.edge) return false\r\n    if (!edgeIntersect(this.p1, this.p2, otherEdgeKey.edge)) return true\r\n    const selfDistance = pointEdgeDistance(this.p1, this.p2, this.edge)\r\n    const otherDistance = pointEdgeDistance(this.p1, this.p2, otherEdgeKey.edge)\r\n    if (selfDistance > otherDistance) return false\r\n    if (selfDistance < otherDistance) return true\r\n    if (selfDistance === otherDistance) {\r\n      let samePoint = null\r\n      if (otherEdgeKey.edge.containsPoint(this.edge.p1)) samePoint = this.edge.p1\r\n      else if (otherEdgeKey.edge.containsPoint(this.edge.p2)) samePoint = this.edge.p2\r\n      const aslf = angle2(this.p1, this.p2, this.edge.getOtherPointInEdge(samePoint))\r\n      const aot = angle2(this.p1, this.p2, otherEdgeKey.edge.getOtherPointInEdge(samePoint))\r\n      if (aslf < aot) return true\r\n      return false\r\n    }\r\n  }\r\n\r\n  matchesOtherKey (otherKey) {\r\n    return this.edge.areEdgesEquals(otherKey.edge)\r\n  }\r\n\r\n}\r\n","var currentPoint = null\r\nvar sortedPointsLg = null\r\nvar openEdges = null\r\nvar map = null\r\n\r\nexport function _renderSortedPoints (point, sortedPoints) {\r\n  if (map === null) map = window.map\r\n\r\n  setCurrentPoint(point)\r\n\r\n  if (sortedPointsLg === null) sortedPointsLg = L.layerGroup([]).addTo(map)\r\n  else sortedPointsLg.clearLayers()\r\n  sortedPoints.forEach((p, index) => {\r\n    return L.marker([p.y, p.x], {\r\n      color: 'black',\r\n      icon: new L.NumberedDivIcon({ number: index })\r\n    }).addTo(sortedPointsLg)\r\n  })\r\n\r\n  debugger\r\n}\r\n\r\nexport function _renderOpenEdges (point, edges) {\r\n  if (map === null) map = window.map\r\n  setCurrentPoint(point)\r\n\r\n  if (openEdges === null) openEdges = L.layerGroup([]).addTo(map)\r\n  else openEdges.clearLayers()\r\n\r\n  edges.forEach((e, index) => {\r\n    L.polyline([[e.edge.p1.y, e.edge.p1.x], [e.edge.p2.y, e.edge.p2.x]], {\r\n      color: 'red'\r\n    }).addTo(openEdges)\r\n  })\r\n\r\n  debugger\r\n\r\n}\r\n\r\nfunction setCurrentPoint (point) {\r\n  if (currentPoint !== null) map.removeLayer(currentPoint)\r\n  currentPoint = L.circleMarker([point.y, point.x], {\r\n    radius: 20,\r\n    color: 'green'\r\n  }).addTo(map)\r\n}\r\n\r\nL.NumberedDivIcon = L.Icon.extend({\r\n  options: {\r\n    number: '',\r\n    iconSize: new L.Point(25, 25),\r\n    className: 'leaflet-div-icon'\r\n  },\r\n\r\n  createIcon: function () {\r\n    var div = document.createElement('div')\r\n    var numdiv = document.createElement('div')\r\n    numdiv.setAttribute('class', 'number')\r\n    numdiv.innerHTML = this.options['number'] || ''\r\n    div.appendChild(numdiv)\r\n    this._setIconStyles(div, 'icon')\r\n    return div\r\n  }\r\n})\r\n","import { coordEach } from '@turf/meta'\r\nimport { Edge } from './Edge'\r\nimport { EdgeKeys } from './EdgeKeys'\r\nimport { EdgeKey } from './EdgeKey'\r\nimport { Point } from './Point'\r\nimport { INF, edgeIntersect, onSegment, ccw, edgeDistance } from './utils'\r\nimport { _renderSortedPoints, _renderOpenEdges } from './debug'\r\n\r\nexport class Graph {\r\n\r\n  constructor (polygons) {\r\n    this.points = []\r\n    this.edges = []\r\n    this.vg = []\r\n\r\n    let prevGeomIndex = 0\r\n    let subtractCoordIndex = 0\r\n\r\n    var g = this\r\n    coordEach(polygons, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n\r\n      if (geometryIndex > prevGeomIndex) {\r\n        prevGeomIndex = geometryIndex\r\n        subtractCoordIndex = coordIndex\r\n      }\r\n      var nextCoordIndex = (coordIndex - subtractCoordIndex) + 1\r\n      if (nextCoordIndex === polygons.features[featureIndex].geometry.coordinates[geometryIndex].length) nextCoordIndex = 0\r\n\r\n      const nextPoint = polygons.features[featureIndex].geometry.coordinates[geometryIndex][nextCoordIndex]\r\n      const p1 = new Point(currentCoord[0], currentCoord[1], geometryIndex)\r\n      const p2 = new Point(nextPoint[0], nextPoint[1], geometryIndex)\r\n\r\n      g.edges.push(new Edge(p1, p2))\r\n      g.points.push(p1)\r\n    }, true)\r\n\r\n  }\r\n\r\n  processGraph () {\r\n    const allVisible = []\r\n    for (var i = 0; i < this.points.length; i++) {\r\n      const p = this.points[i]\r\n\r\n      this.sortPoints(p)\r\n\r\n      // _renderSortedPoints(p, this.points)\r\n\r\n      const openEdges = new EdgeKeys()\r\n      const pointInf = new Point(INF, p.y)\r\n      for (let ii = 0; ii < this.edges.length; ii++) {\r\n        const e = this.edges[ii]\r\n        if (e.containsPoint(p)) continue\r\n        if (edgeIntersect(p, pointInf, e)) {\r\n          if (onSegment(p, e.p1, pointInf) || onSegment(p, e.p2, pointInf)) continue\r\n          openEdges.addKey(new EdgeKey(p, pointInf, e))\r\n        }\r\n      }\r\n      _renderOpenEdges(p, openEdges.keys)\r\n\r\n      const visible = []\r\n      let prev = null\r\n      let prevVisible = null\r\n      for (let ii = 0; ii < this.points.length; ii++) {\r\n        const p2 = this.points[ii]\r\n        if (p2 === p) continue\r\n        if (openEdges.keys.length > 0) {\r\n          for (let iii = 0; iii < this.edges.length; iii++) {\r\n            const e = this.edges[iii]\r\n            if (ccw(p, p2, e.getOtherPointInEdge(p2)) === -1) {\r\n              const k = new EdgeKey(p, p2, e)\r\n              const index = openEdges.findKeyPosition(k) - 1\r\n              if (index < 0) continue\r\n              if (openEdges.keys.length > 0 && openEdges.keys[index].matchesOtherKey(k)) {\r\n                openEdges.keys.splice(index, 1)\r\n              }\r\n            }\r\n          }\r\n        }\r\n        let isVisible = false\r\n        if (prev === null || ccw(p, prev, p2) !== 0 || !onSegment(p, prev, p2)) {\r\n          if (openEdges.keys.length === 0) {\r\n            isVisible = true\r\n          } else if (!edgeIntersect(p, p2, openEdges.keys[0].edge)) {\r\n            isVisible = true\r\n          }\r\n        } else if (!prevVisible) {\r\n          isVisible = false\r\n        } else {\r\n          isVisible = true\r\n          for (let iii = 0; iii < openEdges.keys.length; iii++) {\r\n            const e = openEdges.keys[iii]\r\n            if (!e.edge.containsPoint(prev) && edgeIntersect(prev, p2, e.edge)) {\r\n              isVisible = false\r\n              break\r\n            }\r\n          }\r\n          if (isVisible && this.edgeInPolygon(prev, p2)) isVisible = false\r\n        }\r\n\r\n        var prevPoint = ii === 0 ? this.points[this.points.length - 1] : this.points[ii - 1]\r\n        var nextPoint = ii < this.points.length - 1 ? this.points[ii + 1] : this.points[0]\r\n\r\n        // if (p.x === 14.414062499999998 && p.y === 12.897489183755892) console.log(prevPoint, nextPoint)\r\n        if (isVisible && (!p2.isPointEqual(prevPoint) || !p2.isPointEqual(nextPoint))) isVisible = !this.edgeInPolygon(p, p2)\r\n\r\n        if (isVisible) visible.push(p2)\r\n\r\n        for (let iii = 0; iii < this.edges.length; iii++) {\r\n          const e = this.edges[iii]\r\n          if (!e.containsPoint(p) && ccw(p, p2, e.getOtherPointInEdge(p2)) === 1) {\r\n            const k = new EdgeKey(p, p2, e)\r\n            openEdges.addKey(k)\r\n          }\r\n        }\r\n\r\n        prev = p2\r\n        prevVisible = isVisible\r\n      }\r\n      allVisible.push({\r\n        point: p,\r\n        otherVis: visible\r\n      })\r\n    }\r\n    return allVisible\r\n  }\r\n\r\n  copyPoints () {\r\n    return this.points.slice(0)\r\n  }\r\n\r\n  sortPoints (point) {\r\n    this.points.sort((a, b) => {\r\n      const angle1 = point.angleToPoint(a)\r\n      const angle2 = point.angleToPoint(b)\r\n      if (angle1 < angle2) return -1\r\n      if (angle1 > angle2) return 1\r\n      const dist1 = edgeDistance(a, point)\r\n      const dist2 = edgeDistance(b, point)\r\n      if (dist1 < dist2) return -1\r\n      if (dist1 > dist2) return 1\r\n      return 0\r\n    })\r\n  }\r\n\r\n  edgeInPolygon (p1, p2) {\r\n    if (p1.polygonID !== p2.polygonID) return false\r\n    if (p1.polygonID === -1 || p2.polygonID === -1) return false\r\n    const midPoint = new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)\r\n    return this.polygonCrossing(midPoint, this.edges)\r\n  }\r\n\r\n  polygonCrossing (p1, polyEdges) {\r\n    const p2 = new Point(INF, p1.y)\r\n    let intersectCount = 0\r\n    let coFlag = false\r\n    let coDir = 0\r\n    for (let i = 0; i < polyEdges.length; i++) {\r\n      const e = polyEdges[i]\r\n      if (p1.y < e.p1.y && p1.y < e.p2.y) continue\r\n      if (p1.y > e.p1.y && p1.y < e.p2.y) continue\r\n      const co0 = ccw(p1, e.p1, p2) === 0 && e.p1.x > p1.x\r\n      const co1 = ccw(p1, e.p2, p2) === 0 && e.p2.x > p1.x\r\n      const coPoint = co0 ? e.p1 : e.p2\r\n      if (co0 || co1) {\r\n        coDir = e.getOtherPointInEdge(coPoint).y > p1.y ? coDir++ : coDir--\r\n        if (coFlag) {\r\n          if (coDir === 0) intersectCount++\r\n          coFlag = false\r\n          coDir = 0\r\n        } else {\r\n          coFlag = true\r\n        }\r\n      } else if (edgeIntersect(p1, p2, e)) {\r\n        intersectCount++\r\n      }\r\n    }\r\n    if (intersectCount / 2 === 0) return false\r\n    return true\r\n  }\r\n\r\n}\r\n"],"names":["coordEach","geojson","callback","excludeWrapCoord","j","k","l","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","features","length","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","coordinates","geomType","Error","Edge","p1","p2","polygonID","point","isPointEqual","otherEdge","p12","EdgeKeys","keys","edgekey","lo","hi","mid","Math","floor","isLessThanOtherEdgeKey","findKeyPosition","splice","Point","x","y","undefined","otherPoint","dx","dy","pi1","pi2","PI","atan","edgeDistance","INF","COLIN_TOLERANCE","T","pow","T2","edgeIntersect","q1","edge","q2","o1","ccw","o2","o3","o4","onSegment","a","b","c","area","parseInt","p","q","r","max","min","angle2","p3","acos","sqrt","pointEdgeDistance","ip","intersectPoint","containsPoint","px","pslope","intersectX","intersectY","eslope","EdgeKey","otherEdgeKey","selfDistance","otherDistance","samePoint","aslf","getOtherPointInEdge","aot","otherKey","areEdgesEquals","currentPoint","openEdges","map","_renderOpenEdges","edges","window","L","layerGroup","addTo","clearLayers","forEach","e","index","polyline","setCurrentPoint","removeLayer","circleMarker","NumberedDivIcon","Icon","extend","div","document","createElement","numdiv","setAttribute","innerHTML","options","appendChild","_setIconStyles","Graph","polygons","points","vg","prevGeomIndex","subtractCoordIndex","g","currentCoord","nextCoordIndex","nextPoint","push","allVisible","i","sortPoints","pointInf","ii","addKey","visible","prev","prevVisible","iii","matchesOtherKey","isVisible","edgeInPolygon","prevPoint","slice","sort","angle1","angleToPoint","dist1","dist2","midPoint","polygonCrossing","polyEdges","intersectCount","coFlag","coDir","co0","co1","coPoint"],"mappings":"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"}