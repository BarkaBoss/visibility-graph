{"version":3,"file":"vis-graph.js","sources":["../src/Edge.js","../src/EdgeKeys.js","../src/Point.js","../src/utils.js","../src/EdgeKey.js","../src/Graph.js","../node_modules/@turf/meta/main.es.js"],"sourcesContent":["export class Edge {\r\n  constructor (p1, p2) {\r\n    this.p1 = p1\r\n    this.p2 = p2\r\n  }\r\n\r\n  getOtherPointInEdge (point) {\r\n    return this.p1.isPointEqual(point) ? this.p2 : this.p1\r\n  }\r\n\r\n  areEdgesEqual (otherEdge) {\r\n    if (this.p1.isPointEqual(otherEdge.p1) && this.p2.isPointEqual(otherEdge.p2)) return true\r\n    if (this.p1.isPointEqual(otherEdge.p2) && this.p2.isPointEqual(otherEdge.p1)) return true\r\n    return false\r\n  }\r\n\r\n  containsPoint (point) {\r\n    if (this.p1.isPointEqual(point) || this.p2.isPointEqual(point)) return true\r\n    return false\r\n  }\r\n}\r\n","export class EdgeKeys {\r\n\r\n  constructor () {\r\n    this.keys = []\r\n  }\r\n\r\n  findKeyPosition (edgekey, p) {\r\n    let lo = 0\r\n    let hi = this.keys.length\r\n    while (lo < hi) {\r\n      const mid = Math.floor((lo + hi) / 2)\r\n      if (edgekey.isLessThanOtherEdgeKey(this.keys[mid])) hi = mid\r\n      else lo = mid + 1\r\n    }\r\n    return lo\r\n  }\r\n\r\n  addKey (edgekey, p) {\r\n    const lo = this.findKeyPosition(edgekey)\r\n    this.keys.splice(lo, 0, edgekey)\r\n  }\r\n}\r\n","import { edgeDistance, pi1, pi2 } from './utils'\r\n\r\nexport class Point {\r\n\r\n  constructor (x, y, polygonID) {\r\n    if (polygonID === undefined) polygonID = -1\r\n    this.x = x\r\n    this.y = y\r\n    this.polygonID = polygonID\r\n    this.startingVertice = false\r\n    this.endVertice = false\r\n    this.edges = []\r\n  }\r\n\r\n  isPointEqual (otherPoint) {\r\n    return this.x === otherPoint.x && this.y === otherPoint.y\r\n  }\r\n\r\n  angleToPoint (otherPoint) {\r\n    if (this.x === otherPoint.x && this.y === otherPoint.y) return 0\r\n    const dx = otherPoint.x - this.x\r\n    const dy = otherPoint.y - this.y\r\n    if (dx === 0) dy < 1 ? pi1 : pi2\r\n    if (dy === 0) dx < 0 ? Math.PI : 0\r\n    if (dx < 0) return Math.PI + Math.atan(dy / dx)\r\n    if (dy < 0) return 2 * Math.PI + Math.atan(dy / dx)\r\n    return Math.atan(dy / dx)\r\n  }\r\n\r\n  edgeDistance (otherPoint) {\r\n    return edgeDistance(this, otherPoint)\r\n  }\r\n}\r\n","import { Point } from './Point'\r\n\r\nexport const pi1 = Math.PI * 3 / 2\r\nexport const pi2 = Math.PI / 2\r\n\r\nexport const INF = 10000\r\nconst COLIN_TOLERANCE = 13\r\nconst T = Math.pow(10, COLIN_TOLERANCE)\r\nconst T2 = Math.pow(10.0, COLIN_TOLERANCE)\r\n\r\nexport function edgeIntersect (p1, q1, edge) {\r\n  const p2 = edge.p1\r\n  const q2 = edge.p2\r\n  const o1 = ccw(p1, q1, p2)\r\n  const o2 = ccw(p1, q1, q2)\r\n  const o3 = ccw(p2, q2, p1)\r\n  const o4 = ccw(p2, q2, q1)\r\n  if (o1 !== o2 && o3 !== o4) return true\r\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true\r\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true\r\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true\r\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true\r\n  return false\r\n}\r\n\r\nexport function ccw (a, b, c) {\r\n  const area = parseInt(((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) * T) / T2\r\n  if (area > 0) return 1\r\n  if (area < 0) return -1\r\n  return 0\r\n}\r\n\r\nexport function onSegment (p, q, r) {\r\n  if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x)) {\r\n    if (q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) return true\r\n  }\r\n  return false\r\n}\r\n\r\nexport function angle2 (p1, p2, p3) {\r\n  const a = Math.pow((p3.x - p2.x), 2) + Math.pow((p3.y - p2.y), 2)\r\n  const b = Math.pow((p3.x - p1.x), 2) + Math.pow((p3.y - p1.y), 2)\r\n  const c = Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2)\r\n  return Math.acos((a + c - b) / (2 * Math.sqrt(a) * Math.sqrt(c)))\r\n}\r\n\r\nexport function pointEdgeDistance (p1, p2, edge) {\r\n  const ip = intersectPoint(p1, p2, edge)\r\n  return ip !== null ? edgeDistance(p1, ip) : 0\r\n}\r\n\r\nexport function intersectPoint (p1, p2, edge) {\r\n  if (edge.containsPoint(p1)) return p1\r\n  if (edge.containsPoint(p2)) return p2\r\n  if (edge.p1.x === edge.p2.x) {\r\n    if (p1.x === p2.x) return null\r\n    const pslope = (p1.y - p2.y) / (p1.x - p2.x)\r\n    const intersectX = edge.p1.x\r\n    const intersectY = pslope * (intersectX - p1.x) + p1.y\r\n    return new Point(intersectX, intersectY)\r\n  }\r\n  if (p1.x === p2.x) {\r\n    const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\r\n    const intersectX = p1.x\r\n    const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\r\n    return new Point(intersectX, intersectY)\r\n  }\r\n\r\n  const pslope = (p1.y - p2.y) / (p1.x - p2.x)\r\n  const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\r\n\r\n  if (pslope === eslope) return null\r\n  const intersectX = (eslope * edge.p1.x - pslope * p1.x + p1.y - edge.p1.y) / (eslope - pslope)\r\n  const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\r\n  return new Point(intersectX, intersectY)\r\n}\r\n\r\nexport function edgeDistance (p1, p2) {\r\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2))\r\n}\r\n","import { edgeIntersect, pointEdgeDistance, angle2 } from './utils'\r\n\r\nexport class EdgeKey {\r\n\r\n  constructor (p1, p2, edge) {\r\n    this.p1 = p1\r\n    this.p2 = p2\r\n    this.edge = edge\r\n  }\r\n\r\n  isLessThanOtherEdgeKey (otherEdgeKey) {\r\n    if (this.matchesOtherKey(otherEdgeKey)) return false\r\n\r\n    if (!edgeIntersect(this.p1, this.p2, otherEdgeKey.edge)) return true\r\n    const selfDistance = pointEdgeDistance(this.p1, this.p2, this.edge)\r\n    const otherDistance = pointEdgeDistance(this.p1, this.p2, otherEdgeKey.edge)\r\n    if (selfDistance > otherDistance) return false\r\n    if (selfDistance < otherDistance) return true\r\n    if (selfDistance === otherDistance) {\r\n      let samePoint = null\r\n      if (otherEdgeKey.edge.containsPoint(this.edge.p1)) samePoint = this.edge.p1\r\n      else if (otherEdgeKey.edge.containsPoint(this.edge.p2)) samePoint = this.edge.p2\r\n      const aslf = angle2(this.p1, this.p2, this.edge.getOtherPointInEdge(samePoint))\r\n      const aot = angle2(this.p1, this.p2, otherEdgeKey.edge.getOtherPointInEdge(samePoint))\r\n      if (aslf < aot) return true\r\n      return false\r\n    }\r\n  }\r\n\r\n  matchesOtherKey (otherKey) {\r\n    return this.edge.areEdgesEqual(otherKey.edge)\r\n  }\r\n\r\n}\r\n","import { coordEach } from '@turf/meta'\r\nimport { Edge } from './Edge'\r\nimport { EdgeKeys } from './EdgeKeys'\r\nimport { EdgeKey } from './EdgeKey'\r\nimport { Point } from './Point'\r\nimport { INF, edgeIntersect, onSegment, ccw, edgeDistance } from './utils'\r\nimport { _renderSortedPoints, _renderOpenEdges } from './debug' //eslint-disable-line\r\n\r\nexport class Graph {\r\n\r\n  constructor (polygons) {\r\n    this.points = []\r\n    this.vg = []\r\n    this.edges = []\r\n    this.polygons = [[]]\r\n\r\n    let prevGeomIndex = 0\r\n    let subtractCoordIndex = 0\r\n    let prevFeatureIndex = 0\r\n    let startNewFeatureIndex = 0\r\n    var g = this\r\n    let prevPoint = null\r\n\r\n    coordEach(polygons, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n      let newFeature = false\r\n      if (geometryIndex > prevGeomIndex) {\r\n        prevGeomIndex = geometryIndex\r\n        subtractCoordIndex = coordIndex\r\n      }\r\n      if (featureIndex > prevFeatureIndex) {\r\n        g.points[g.points.length - 1].edges.push(g.points[startNewFeatureIndex].edges[0])\r\n        prevPoint.endVertice = true\r\n        prevPoint.endVerticeStart = startNewFeatureIndex\r\n        prevFeatureIndex = featureIndex\r\n        newFeature = true\r\n        startNewFeatureIndex = coordIndex\r\n        g.polygons.push([])\r\n      }\r\n\r\n      const currentPoint = new Point(currentCoord[0], currentCoord[1], featureIndex)\r\n      g.points.push(currentPoint)\r\n\r\n      if (coordIndex - subtractCoordIndex === 0 || newFeature) {\r\n        currentPoint.startingVertice = true\r\n        currentPoint.endVerticeStart = polygons.features[featureIndex].geometry.coordinates[geometryIndex].length - 2\r\n        const prevPointCoords = polygons.features[featureIndex].geometry.coordinates[geometryIndex][polygons.features[featureIndex].geometry.coordinates[geometryIndex].length - 2]\r\n        prevPoint = new Point(prevPointCoords[0], prevPointCoords[1], featureIndex)\r\n      }\r\n\r\n      const currentEdge = new Edge(prevPoint, currentPoint)\r\n      currentPoint.edges.push(currentEdge)\r\n      prevPoint.edges.push(currentEdge)\r\n      g.polygons[featureIndex].push(currentEdge)\r\n      g.edges.push(currentEdge)\r\n      prevPoint = currentPoint\r\n\r\n    }, true)\r\n    this.points[this.points.length - 1].edges.push(this.points[startNewFeatureIndex].edges[0])\r\n    prevPoint.endVertice = true\r\n    prevPoint.endVerticeStart = startNewFeatureIndex\r\n  }\r\n\r\n  processGraph () {\r\n    const allVisible = []\r\n    for (var i = 0; i < this.points.length; i++) {\r\n      const p = this.points[i]\r\n      const prevPoint = !p.startingVertice ? this.points[i - 1] : this.points[i + p.endVerticeStart]\r\n      const nextPoint = !p.endVertice ? this.points[i + 1] : this.points[p.endVerticeStart]\r\n\r\n      var clonedPoints = this.clonePoints()\r\n      this.sortPoints(p, clonedPoints)\r\n      // _renderSortedPoints(p, clonedPoints)\r\n\r\n      const openEdges = new EdgeKeys()\r\n      const pointInf = new Point(INF, p.y)\r\n      for (let ii = 0; ii < this.edges.length; ii++) {\r\n        const e = this.edges[ii]\r\n        if (e.containsPoint(p)) continue\r\n        if (edgeIntersect(p, pointInf, e)) {\r\n          if (onSegment(p, e.p1, pointInf) || onSegment(p, e.p2, pointInf)) continue\r\n          openEdges.addKey(new EdgeKey(p, pointInf, e))\r\n        }\r\n      }\r\n      // _renderOpenEdges(p, openEdges.keys)\r\n\r\n      const visible = []\r\n      let prev = null\r\n      let prevVisible = null\r\n      for (let ii = 0; ii < clonedPoints.length; ii++) {\r\n        const p2 = clonedPoints[ii]\r\n        if (p2 === p) continue\r\n        if (openEdges.keys.length > 0) {\r\n          for (let iii = 0; iii < p2.edges.length; iii++) {\r\n            const e = p2.edges[iii]\r\n            if (ccw(p, p2, e.getOtherPointInEdge(p2)) === -1) {\r\n              const k = new EdgeKey(p, p2, e)\r\n              const index = openEdges.findKeyPosition(k) - 1\r\n              if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\r\n                openEdges.keys.splice(index, 1)\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        let isVisible = false\r\n        if (prev === null || ccw(p, prev, p2) !== 0 || !onSegment(p, prev, p2)) {\r\n          if (openEdges.keys.length === 0) {\r\n            isVisible = true\r\n          } else if (!edgeIntersect(p, p2, openEdges.keys[0].edge)) {\r\n            isVisible = true\r\n          }\r\n        } else if (!prevVisible) {\r\n          isVisible = false\r\n        } else {\r\n          isVisible = true\r\n          for (let iii = 0; iii < openEdges.keys.length; iii++) {\r\n            const e = openEdges.keys[iii]\r\n            if (!e.edge.containsPoint(prev) && edgeIntersect(prev, p2, e.edge)) {\r\n              isVisible = false\r\n              break\r\n            }\r\n          }\r\n          if (isVisible && this.edgeInPolygon(prev, p2)) isVisible = false\r\n        }\r\n\r\n        const isInAdjacentPoints = p2.isPointEqual(prevPoint) || p2.isPointEqual(nextPoint)\r\n        if (isVisible && !isInAdjacentPoints) isVisible = !this.edgeInPolygon(p, p2)\r\n\r\n        if (isVisible) visible.push(p2)\r\n\r\n        for (let iii = 0; iii < p2.edges.length; iii++) {\r\n          const e = p2.edges[iii]\r\n          if (!e.containsPoint(p) && ccw(p, p2, e.getOtherPointInEdge(p2)) === 1) {\r\n            const k = new EdgeKey(p, p2, e)\r\n            openEdges.addKey(k)\r\n          }\r\n        }\r\n\r\n        prev = p2\r\n        prevVisible = isVisible\r\n      }\r\n      allVisible.push({\r\n        point: p,\r\n        otherVis: visible\r\n      })\r\n    }\r\n    return allVisible\r\n  }\r\n\r\n  clonePoints () {\r\n    return this.points.slice(0)\r\n  }\r\n\r\n  sortPoints (point, clonedPoints) {\r\n    clonedPoints.sort((a, b) => {\r\n      const angle1 = point.angleToPoint(a)\r\n      const angle2 = point.angleToPoint(b)\r\n      if (angle1 < angle2) return -1\r\n      if (angle1 > angle2) return 1\r\n      const dist1 = edgeDistance(a, point)\r\n      const dist2 = edgeDistance(b, point)\r\n      if (dist1 < dist2) return -1\r\n      if (dist1 > dist2) return 1\r\n      return 0\r\n    })\r\n  }\r\n\r\n  findPoint (p) {\r\n    for (var i = 0; i < this.points.length; i++) {\r\n      if (this.points[i].isPointEqual(p)) return this.points[i]\r\n    }\r\n  }\r\n\r\n  edgeInPolygon (p1, p2) {\r\n    if (p1.polygonID !== p2.polygonID) return false\r\n    if (p1.polygonID === -1 || p2.polygonID === -1) return false\r\n    const midPoint = new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)\r\n    return this.polygonCrossing(midPoint, this.polygons[p1.polygonID])\r\n  }\r\n\r\n  polygonCrossing (p1, polyEdges) {\r\n    const p2 = new Point(INF, p1.y)\r\n    let intersectCount = 0\r\n    let coFlag = false\r\n    let coDir = 0\r\n\r\n    for (let i = 0; i < polyEdges.length; i++) {\r\n      const e = polyEdges[i]\r\n      if (p1.y < e.p1.y && p1.y < e.p2.y) continue\r\n      if (p1.y > e.p1.y && p1.y > e.p2.y) continue\r\n      const co0 = (ccw(p1, e.p1, p2) === 0) && (e.p1.x > p1.x)\r\n      const co1 = (ccw(p1, e.p2, p2) === 0) && (e.p2.x > p1.x)\r\n      const coPoint = co0 ? e.p1 : e.p2\r\n      if (co0 || co1) {\r\n        coDir = e.getOtherPointInEdge(coPoint).y > p1.y ? coDir++ : coDir--\r\n        if (coFlag) {\r\n          if (coDir === 0) intersectCount++\r\n          coFlag = false\r\n          coDir = 0\r\n        } else {\r\n          coFlag = true\r\n        }\r\n      } else if (edgeIntersect(p1, p2, e)) {\r\n        intersectCount++\r\n      }\r\n    }\r\n    if (intersectCount % 2 === 0) return false\r\n    return true\r\n  }\r\n\r\n}\r\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n"],"names":["Edge","p1","p2","point","this","isPointEqual","otherEdge","EdgeKeys","keys","edgekey","p","lo","hi","length","mid","Math","floor","isLessThanOtherEdgeKey","findKeyPosition","splice","Point","x","y","polygonID","undefined","startingVertice","endVertice","edges","otherPoint","dx","dy","PI","atan","edgeDistance","T","pow","T2","edgeIntersect","q1","edge","q2","o1","ccw","o2","o3","o4","onSegment","a","b","c","area","parseInt","q","r","max","min","angle2","p3","acos","sqrt","pointEdgeDistance","ip","containsPoint","pslope","intersectX","intersectY","eslope","intersectPoint","EdgeKey","otherEdgeKey","matchesOtherKey","selfDistance","otherDistance","samePoint","getOtherPointInEdge","otherKey","areEdgesEqual","Graph","polygons","points","vg","prevGeomIndex","subtractCoordIndex","prevFeatureIndex","startNewFeatureIndex","g","prevPoint","coordEach","geojson","callback","excludeWrapCoord","j","k","l","geometry","stopG","coords","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","type","isFeatureCollection","isFeature","stop","features","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","coordinates","geomType","Error","currentCoord","newFeature","push","endVerticeStart","currentPoint","prevPointCoords","currentEdge","allVisible","i","nextPoint","clonedPoints","clonePoints","sortPoints","openEdges","pointInf","ii","e","addKey","visible","prev","prevVisible","iii","index","isVisible","edgeInPolygon","isInAdjacentPoints","slice","sort","angle1","angleToPoint","dist1","dist2","midPoint","polygonCrossing","polyEdges","intersectCount","coFlag","coDir","co0","co1","coPoint"],"mappings":"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"}